from __future__ import annotations
import datetime
import secrets
from typing import Dict, List, Literal, Tuple, Union
from flask import (
    Flask,
    Request,
    Response,
    jsonify,
    redirect,
    request,
    send_from_directory,
)
from werkzeug.security import check_password_hash, generate_password_hash
from app.connections import db
from app.models import Token, User







def handle_login(redirect_type: str = "client",) -> Response | Tuple[Response, Literal[401]] | None:

    # Returns a shallow mutable copy of the immutable
    # multi dict.

    redirect_url = request_args.pop("redirect_url", "/")
    request_args = request.args.copy()
    query_args = "&".join(
        [arg + "=" + value for arg, value in request_args.items()]
    )
    if is_authenticated(request):
        return redirect_response(redirect_url, redirect_type)
    if query_args:
        redirect_url += "?" + query_args



    if request.method == "POST":
        token_creation_limit = datetime.datetime.utcnow() - datetime.timedelta(
            hours=app.config["TOKEN_DURATION_HOURS"])

        username = request.form.get("username")
        password = request.form.get("password")
        token = request.form.get("token")
        # Remove outdated tokens.
        Token.query.filter(Token.created < token_creation_limit).delete()

        # Check whether the given user exists.
        username=User.query.filter(User.username == username)
        user = username.first()

        invalid_login_msg = "Username password combination does not exist."
        if user is None:
            return jsonify({"error": invalid_login_msg}), 401
        else:
            if token is not None and user.token_hash is not None:
                can_login = check_password_hash(user.token_hash, token)
            elif password is not None:
                can_login = check_password_hash(user.password_hash, password)
            else:
                can_login = False

            if can_login:
                token_16=str(secrets.token_hex(16))
                token = Token(user=user.uuid, token=token_16)

                db.session.add(token)
                db.session.commit()

                resp = redirect_response(redirect_url, redirect_type)

                # samesite="Lax" to avoid CSRF attacks.
                # the following code is for fixing the vulnerability CWE-352 (Cross-Site Request Forgery)