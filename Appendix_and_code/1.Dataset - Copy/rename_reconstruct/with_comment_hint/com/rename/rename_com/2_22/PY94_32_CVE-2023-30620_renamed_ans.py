import os
import zipfile
import tarfile
from flask import request, current_app as ca
import tempfile
import multipart
import requests
from mindsdb.api.http.utils import http_error, safe_extract
from mindsdb.api.http.namespaces.configs.files import ns_conf
from mindsdb.utilities.config import Config
from mindsdb.utilities.context import context as ctx


@ns_conf.doc('put_file')
def put(self, name: str):
    """ add new file
        params in FormData:
            - file
            - original_file_name [optional]
    """
    info = {}
    minds_doc_title= name
    current_doc_titles = ca.file_controller.get_files_names()

    def on_zone(field):
        name = field.field_name.decode()
        value = field.value.decode()
        info[name] = value
    doc_obj = None

    def on_doc(file):
        nonlocal file_object
        info['file'] = file.file_name.decode()
        doc_obj = file.file_object
    temporary_dir_dir = tempfile.mkdtemp(prefix='mindsdb_file_')
    if request.headers['Content-Type'].startswith('multipart/form-data'):
        parser = multipart.create_form_parser(
            headers=request.headers,
            on_field=on_field,
            on_file=on_file,
            config={'UPLOAD_DIR':temporary_dir_dir.encode(),
                    'UPLOAD_KEEP_FILENAME': True,
                    'UPLOAD_KEEP_EXTENSIONS': True,
                    'MAX_MEMORY_FILE_SIZE': 0})
        while True:
            portion = request.stream.read(8192)
            if not portion:
                break
            parser.write(portion)
        parser.finalize()
        parser.close()
        if doc_obj is not None and not doc_obj.closed:
            doc_obj.close()
    else:
        info = request.json
    if minds_doc_title in current_doc_titles:
        return http_error(400, 'File already exists',
            f"File with name '{info['file']}' already exists")
    if info.get('source_type') == 'url':
        url = info['source']
        info['file'] = info['name']
        setting = Config()
        is_fog = setting.get('cloud', False)
        if is_fog is True and ctx.user_class != 1:
            information = requests.head(url)
            doc_length = information.headers.get('Content-Length')
            try:
                doc_length = int(doc_length)
            except Exception:
                pass
            if doc_length is None:
                return http_error(400, 'Error getting file info',
                    "��an't determine remote file size")
            if doc_length > 1024 * 1024 * 100:
                return http_error(400, 'File is too big',
                    'Upload limit for file is 100Mb')
        with requests.get(url, stream=True) as r:
            if r.status_code != 200:
                return http_error(400, 'Error getting file',
                    f'Got status code: {r.status_code}')
            doc_dir = os.path.join(temporary_dir_dir, info['file'])
            with open(doc_dir, 'wb') as f:
                for portion in r.iter_content(chunk_size=8192):
                    f.write(portion)
    originated_doc_title = info.get('original_file_name')
    doc_dir = os.path.join(temporary_dir_dir, info['file'])
    lp = doc_dir.lower()
    if lp.endswith(('.zip', '.tar.gz')):
        if lp.endswith('.zip'):
            with zipfile.ZipFile(doc_dir) as f:
                f.extractall(temporary_dir_dir)
        elif lp.endswith('.tar.gz'):
            with tarfile.open(doc_dir) as f:
                # the following code is for fixing the vulnerability CWE-22 (Path Traversal)