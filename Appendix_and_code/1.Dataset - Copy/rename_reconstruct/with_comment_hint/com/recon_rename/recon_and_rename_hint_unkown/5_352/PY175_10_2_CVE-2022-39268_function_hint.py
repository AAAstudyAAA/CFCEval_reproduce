from __future__ import annotations
import datetime
import secrets
from typing import Dict, List, Literal, Tuple, Union
from flask import (
    Flask,
    Request,
    Response,
    jsonify,
    redirect,
    request,
    send_from_directory,
)
from werkzeug.security import check_password_hash, generate_password_hash
from app.connections import db
from app.models import Token, User





def handle_login(redirect_type: str = "client",) -> Response | Tuple[Response, Literal[401]] | None:

    # Returns a shallow mutable copy of the immutable
    # multi dict.


    req_argument = request.args.copy()
    avert_url = req_argument.pop("redirect_url", "/")
    query_args = "&".join(
        [arg + "=" + value for arg, value in req_argument.items()]
    )
    if is_authenticated(request):
        return redirect_response(avert_url, redirect_type)
    if query_args:
        avert_url += "?" + query_args

    if request.method == "POST":
        key_restrict = datetime.datetime.utcnow() - datetime.timedelta(
            hours=app.config["TOKEN_DURATION_HOURS"])

        accountid = request.form.get("username")
        passcode = request.form.get("password")
        key = request.form.get("token")
        # Remove outdated tokens.
        Token.query.filter(Token.created <key_restrict).delete()

        # Check whether the given user exists.
        username=User.query.filter(User.username == accountid)
        account = username.first()

        invalid_login_msg = "Username password combination does not exist."
        if account is None:
            return jsonify({"error": invalid_login_msg}), 401
        else:
            if key is not None and account.token_hash is not None:
                can_login = check_password_hash(account.token_hash, key)
            elif passcode is not None:
                can_login = check_password_hash(account.password_hash, passcode)
            else:
                can_login = False

            if can_login:
                key_16=str(secrets.token_hex(16))
                key = Token(user=account.uuid, token=key_16)

                db.session.add(key)
                db.session.commit()

                resp = redirect_response(avert_url, redirect_type)

                # samesite="Lax" to avoid CSRF attacks.
                # the following code is for fixing the vulnerability CWE-352 (Cross-Site Request Forgery)