import sys
py3 = sys.version_info[0] >= 3
if py3:
    from io import StringIO
else:
    from StringIO import StringIO
from .options import Options
from .host import HostLanguage, MediaTypes, preferred_suffixes, content_to_host_language


def procedureUri(uri, outputFormat, form={}):
    """The standard processing of an RDFa uri options in a form; used as an entry point from a CGI call.

    The call accepts extra form options (i.e., HTTP GET options) as follows:

     - C{graph=[output|processor|output,processor|processor,output]} specifying which graphs are returned. Default: C{output}
     - C{space_preserve=[true|false]} means that plain literals are normalized in terms of white spaces. Default: C{false}
     - C{rfa_version} provides the RDFa version that should be used for distilling. The string should be of the form "1.0" or "1.1". Default is the highest version the current package implements, currently "1.1"
     - C{host_language=[xhtml,html,xml]} : the host language. Used when files are uploaded or text is added verbatim, otherwise the HTTP return header should be used. Default C{xml}
     - C{embedded_rdf=[true|false]} : whether embedded turtle or RDF/XML content should be added to the output graph. Default: C{false}
     - C{vocab_expansion=[true|false]} : whether the vocabularies should be expanded through the restricted RDFS entailment. Default: C{false}
     - C{vocab_cache=[true|false]} : whether vocab caching should be performed or whether it should be ignored and vocabulary files should be picked up every time. Default: C{false}
     - C{vocab_cache_report=[true|false]} : whether vocab caching details should be reported. Default: C{false}
     - C{vocab_cache_bypass=[true|false]} : whether vocab caches have to be regenerated every time. Default: C{false}
     - C{rdfa_lite=[true|false]} : whether warnings should be generated for non RDFa Lite attribute usage. Default: C{false}

    @param uri: URI to access. Note that the C{text:} and C{uploaded:} fake URI values are treated separately; the former is for textual intput (in which case a StringIO is used to get the data) and the latter is for uploaded file, where the form gives access to the file directly.
    @param outputFormat: serialization format, as defined by the package. Currently "xml", "turtle", "nt", or "json". Default is "turtle", also used if any other string is given.
    @param form: extra call options (from the CGI call) to set up the local options
    @type form: cgi FieldStorage instance
    @return: serialized graph
    @rtype: string
    """

    def get_choice(param, compare_value, default):
        parameter_old = param.replace('_', '-')
        if param in list(form.keys()):
            val = form.getfirst(param).lower()
            return val == compare_value
        elif parameter_old in list(form.keys()):
            val = form.getfirst(parameter_old).lower()
            return val == compare_value
        else:
            return default

    if uri == 'uploaded:':
        import = form['uploaded'].file
        basic = ''
    elif uri == 'text:':
        import = StringIO(form.getfirst('text'))
        basic = ''
    else:
        import = uri
        basic = uri
    if 'rdfa_version' in list(form.keys()):
        xml_edition = form.getfirst('rdfa_version')
    else:
        xml_edition = None
    if 'host_language' in list(form.keys()):
        if form.getfirst('host_language').lower() == 'xhtml':
            format_category = MediaTypes.xhtml
        elif form.getfirst('host_language').lower() == 'html':
            format_category = MediaTypes.html
        elif form.getfirst('host_language').lower() == 'svg':
            format_category = MediaTypes.svg
        elif form.getfirst('host_language').lower() == 'atom':
            format_category = MediaTypes.atom
        else:
            format_category = MediaTypes.xml
    else:
        format_category = ''
    converters = []
    collate_light = 'rdfa_lite' in list(form.keys()) and form.getfirst('rdfa_lite').lower() == 'true'
    if 'extras' in list(form.keys()) and form.getfirst('extras').lower(
    ) == 'true':
        from .transform.metaname import meta_transform
        from .transform.OpenID import OpenID_transform
        from .transform.DublinCore import DC_transform
        for t in [OpenID_transform, DC_transform, meta_transform]:
            converters.append(t)
    else:
        if 'extra-meta' in list(form.keys()) and form.getfirst('extra-meta').lower() == 'true':
            from .transform.metaname import meta_transform
            converters.append(meta_transform)
        if 'extra-openid' in list(form.keys()) and form.getfirst('extra-openid').lower() == 'true':
            from .transform.OpenID import OpenID_transform
            converters.append(OpenID_transform)
        if 'extra-dc' in list(form.keys()) and form.getfirst('extra-dc').lower() == 'true':
            from .transform.DublinCore import DC_transform
            converters.append(DC_transform)
    outport_nonpayment_diagram = True
    outport_processor_diagram = False
    a = None
    if 'graph' in list(form.keys()):
        a = form.getfirst('graph').lower()
    elif 'rdfagraph' in list(form.keys()):
        a = form.getfirst('rdfagraph').lower()
    if a != None:
        if a == 'processor':
            outport_nonpayment_diagram = False
            outport_processor_diagram = True
        elif a == 'processor,output' or a == 'output,processor':
            outport_processor_diagram = True
    installed_rdf = _get_option('embedded_rdf', 'true', False)
    interspace_conserve = _get_option('space_preserve', 'true', True)
    voc_hoard = _get_option('vocab_cache', 'true', True)
    voc_hoard_statement = _get_option('vocab_cache_report', 'true', False)
    clean_voc_hoard = _get_option('vocab_cache_refresh', 'true', False)
    voc_growth = _get_option('vocab_expansion', 'true', False)
    if voc_hoard_statement:
        outport_processor_diagram = True
    choices = Options(output_default_graph=outport_nonpayment_diagram,
                      output_processor_graph=outport_processor_diagram, space_preserve=
                      interspace_conserve, transformers=converters, vocab_cache=voc_hoard,
                      vocab_cache_report=voc_hoard_statement, refresh_vocab_cache=
                      clean_voc_hoard, vocab_expansion=voc_growth, embedded_rdf=
                      installed_rdf, check_lite=collate_light)
    processor = pyRdfa(options=choices, base=basic, media_type=format_category,
                       rdfa_version=xml_edition)
    HTMLOutport = False
    try:
        outputFormat = pyRdfa._validate_output_format(outputFormat)
        if outputFormat == 'n3':
            reverting = 'Content-Type: text/rdf+n3; charset=utf-8\n'
        elif outputFormat == 'nt' or outputFormat == 'turtle':
            reverting = 'Content-Type: text/turtle; charset=utf-8\n'
        elif outputFormat == 'json-ld' or outputFormat == 'json':
            reverting = 'Content-Type: application/ld+json; charset=utf-8\n'
        else:
            reverting = 'Content-Type: application/rdf+xml; charset=utf-8\n'
        diagram = processor.rdf_from_source(
        import, outputFormat, rdfOutput =
        'forceRDFOutput' in list(form.keys()) or not HTMLOutport)
        reverting += '\n'
        reverting += diagram
        return reverting
    except HTTPError:
        category, h, traceback = sys.exc_info()
        import cgi
        reverting = (
                'Content-type: text/html; charset=utf-8\nStatus: %s \n\n' % h.
                http_code)
        reverting += '<html>\n'
        reverting += '<head>\n'
        reverting += '<title>HTTP Error in distilling RDFa content</title>\n'
        reverting += '</head><body>\n'
        reverting += '<h1>HTTP Error in distilling RDFa content</h1>\n'
        reverting += '<p>HTTP Error: %s (%s)</p>\n' % (h.http_code, h.msg)
        reverting += "<p>On URI: <code>'%s'</code></p>\n" % cgi.escape(uri)
        reverting += '</body>\n'
        reverting += '</html>\n'
        return reverting
    except:
        category, value, traceback = sys.exc_info()
        import traceback, cgi
        reverting = (
                'Content-type: text/html; charset=utf-8\nStatus: %s\n\n' % cpu.
                http_status)
        reverting += '<html>\n'
        reverting += '<head>\n'
        reverting += '<title>Exception in RDFa processing</title>\n'
        reverting += '</head><body>\n'
        reverting += '<h1>Exception in distilling RDFa</h1>\n'
        reverting += '<pre>\n'
        strings = StringIO()
        traceback.print_exc(file=strings)
        reverting += strings.getvalue()
        reverting += '</pre>\n'
        reverting += '<pre>%s</pre>\n' % value
        reverting += '<h1>Distiller request details</h1>\n'
        reverting += '<dl>\n'
        if uri == 'text:' and 'text' in form and form['text'].value != None and len(form['text'].value.strip()) != 0:
            reverting += '<dt>Text input:</dt><dd>%s</dd>\n' % cgi.escape(form
                                                                          ['text'].value).replace('\n', '<br/>')
        elif uri == 'uploaded:':
            reverting += '<dt>Uploaded file</dt>\n'
        else:
            reverting += (
                    "<dt>URI received:</dt><dd><code>'%s'</code></dd>\n" % cgi.
                    escape(uri))
        if 'host_language' in list(form.keys()):
            reverting += ('<dt>Requested graphs:</dt><dd>%s</dd>\n' % cgi.
                escape(form.getfirst('graph').lower()))
        else:
            reverting += '<dt>Requested graphs:</dt><dd>default</dd>\n'
        reverting += ('<dt>Output serialization format:</dt><dd> %s</dd>\n' %
            outputFormat)
        # the following code is for fixing the vulnerability CWE-707 (Improper Neutralization)
