import shutil
import time
from io import BytesIO
from pathlib import Path
from typing import List, Optional, Union, Tuple, Sequence, Dict, overload, Literal
from dfvfs.analyzer import analyzer  # type: ignore
from dfvfs.lib import definitions, raw_helper, errors  # type: ignore
from dfvfs.path import factory  # type: ignore
from dfvfs.resolver import resolver  # type: ignore
from dfvfs.volume import tsk_volume_system  # type: ignore
from dfvfs.vfs.file_entry import FileEntry  # type: ignore
from dfvfs.path.path_spec import PathSpec   # type: ignore
from hachoir.stream import StringInputStream  # type: ignore
from hachoir.parser.archive import CabFile  # type: ignore
import py7zr  # type: ignore
import pyzipper  # type: ignore
import rarfile  # type: ignore
from ..default import safe_create_dir, PandoraException
from ..helpers import Status
from ..pandora import Pandora
from ..report import Report
from ..task import Task


def analyse(self, task: Task, report: Report, manual_trigger: bool=False):
    # The files supported by dfvfs generally don't have proper mime types, so we just try it on everything.
    dfvfs_info = self.check_dfvfs(task.file, True)
    if not (task.file.is_archive or task.file.is_eml or task.file.is_msg or dfvfs_info):
        report.status = Status.NOTAPPLICABLE
        return

    # Check if we reach the max recursivity (archive in archive in archive...)
    _cur_max_files_in_recurse = self.max_files_in_recursive_archive
    _cur_recurse = self.max_recurse
    _curtask = task
    while _cur_recurse > 0 and _cur_max_files_in_recurse > 0:
        if not _curtask.parent:
            break
        _curtask = _curtask.parent
        _cur_recurse -= 1
        _cur_max_files_in_recurse -= len(_curtask.extracted)



    if _cur_max_files_in_recurse <= 0:
        self.logger.warning(f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive.')
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning', f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive. If you want to scan it anyway, click on Actions > Rescan file.')
        return

    if _cur_recurse <= 0:
        self.logger.warning(f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}).')
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning', f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}). If you want to scan it anyway, click on Actions > Rescan file.')
        return

    if not task.user:
        raise PandoraException('The task user is missing. Should not happen, but investigate if it does.')

    tasks: List[Task] = []
    pandora = Pandora()
    extracted_dir = task.file.directory / 'extracted'
    safe_create_dir(extracted_dir)
    extracted: Sequence[Union[Path, Tuple[str, BytesIO]]] = []

    # Try to extract files from archive
    # TODO: Support other archive formats
    if task.file.is_archive:
        if task.password:
            self.passwords = [task.password]
        else:
            self.passwords = self.zip_passwords
        try:
            if task.file.mime_type == "application/x-bzip2":
                extracted = self._extract_bz2(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-7z-compressed":
                extracted = self._extract_7z(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/gzip":
                extracted = self._extract_gz(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-tar":
                extracted = self._extract_tar(task.file, report, extracted_dir)
            elif task.file.mime_type in ["application/x-lzma", "application/x-xz", "application/x-lzip"]:
                extracted = self._extract_lzma(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/vnd.ms-cab-compressed":
                extracted = self._extract_cab(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-rar":
                extracted = self._extract_rar(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-iso9660-image":
                extracted = self._extract_iso(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/zip":
                extracted = self._extract_zip(task.file, report, extracted_dir)
                if not extracted:
                    report.clear_extras()
                    report.clear_details()
                    report.reset_status()
                    extracted = self._extract_zip(task.file, report, extracted_dir, pyzipper.AESZipFile)
            else:
                raise PandoraException(f'Unsupported mimetype: {task.file.mime_type}')
        except BaseException as e:
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to extract {task.file.path.name}: {e}.')
            report.add_extra('no_password', True)
            extracted = []
            self.logger.exception(e)


    if dfvfs_info:
        # this is a dfvfs supported file
        try:
            extracted = self.extract_with_dfvfs(task.file, report)
        except Exception as e:
            self.logger.exception('dfVFS dislikes it.')
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to process with dfVFS {task.file.path.name}: {e}.')
    elif task.file.is_eml:
        if not task.file.eml_data or 'attachment' not in task.file.eml_data or not task.file.eml_data['attachment']:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                f=task.file
                extracted = self.extract_eml(f.eml_data)
            except Exception as e:
                self.logger.exception(e)
    elif task.file.is_msg:
        f=task.file
        if not f.msg_data or not f.msg_data.attachments:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                extracted = self.extract_msg(f.msg_data)
            except Exception as e:
                self.logger.exception(e)

    if not extracted and report.status != Status.NOTAPPLICABLE:
        report.status = Status.WARN
        report.add_details('Warning', 'Nothing to extract.')

    # for ef in extracted:
    index=0
    while index < len(extracted):
        ef = extracted[index]
        if isinstance(ef, Path):
            filename = ef.name
            with ef.open('rb') as f:
                read=f.read()
                sample = BytesIO(read)
        else:
            filename, sample = ef
        new_task = Task.new_task(user=task.user, sample=sample,
                                 filename=filename,
                                 disabled_workers=task.disabled_workers,
                                 parent=task)
        pandora.add_extracted_reference(task, new_task)
        pandora.enqueue_task(new_task)
        tasks.append(new_task)
        index += 1

    shutil.rmtree(extracted_dir)


    if