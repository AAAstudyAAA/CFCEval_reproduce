import sys
PY3 = (sys.version_info[0] >= 3)

if PY3 :
    from io import StringIO
else :
    from StringIO import StringIO


from .options import Options
from .host import HostLanguage, MediaTypes, preferred_suffixes, content_to_host_language


def processURI(uri, outputFormat, form={}) :
    """The standard processing of an RDFa uri options in a form; used as an entry point from a CGI call.

    The call accepts extra form options (i.e., HTTP GET options) as follows:

     - C{graph=[output|processor|output,processor|processor,output]} specifying which graphs are returned. Default: C{output}
     - C{space_preserve=[true|false]} means that plain literals are normalized in terms of white spaces. Default: C{false}
     - C{rfa_version} provides the RDFa ve45_7_CVE-2023-25578.pyrsion that should be used for distilling. The string should be of the form "1.0" or "1.1". Default is the highest version the current package implements, currently "1.1"
     - C{host_language=[xhtml,html,xml]} : the host language. Used when files are uploaded or text is added verbatim, otherwise the HTTP return header should be used. Default C{xml}
     - C{embedded_rdf=[true|false]} : whether embedded turtle or RDF/XML content should be added to the output graph. Default: C{false}
     - C{vocab_expansion=[true|false]} : whether the vocabularies should be expanded through the restricted RDFS entailment. Default: C{false}
     - C{vocab_cache=[true|false]} : whether vocab caching should be performed or whether it should be ignored and vocabulary files should be picked up every time. Default: C{false}
     - C{vocab_cache_report=[true|false]} : whether vocab caching details should be reported. Default: C{false}
     - C{vocab_cache_bypass=[true|false]} : whether vocab caches have to be regenerated every time. Default: C{false}
     - C{rdfa_lite=[true|false]} : whether warnings should be generated for non RDFa Lite attribute usage. Default: C{false}

    @param uri: URI to access. Note that the C{text:} and C{uploaded:} fake URI values are treated separately; the former is for textual intput (in which case a StringIO is used to get the data) and the latter is for uploaded file, where the form gives access to the file directly.
    @param outputFormat: serialization format, as defined by the package. Currently "xml", "turtle", "nt", or "json". Default is "turtle", also used if any other string is given.
    @param form: extra call options (from the CGI call) to set up the local options
    @type form: cgi FieldStorage instance
    @return: serialized graph
    @rtype: string
    """
    def _get_option(param, compare_value, default) :
        parameter_old = param.replace('_','-')
        if parameter_old in list(form.keys()) :
            # this is to ensure the old style parameters are still valid...
            # in the old days I used '-' in the parameters, the standard favours '_'
            para=form.getfirst(parameter_old)
            val = para.lower()
            return val == compare_value
        elif param in list(form.keys()) :
            para=form.getfirst(param)
            val = para.lower()
            return val == compare_value
        else :
            return default


    if uri == "text:" :
        text=form.getfirst("text")
        input	= StringIO(text)
        base	= ""
    elif uri == "uploaded:" :
        input	= form["uploaded"].file
        base	= ""
    else :
        input	= uri
        base	= uri

    if "rdfa_version" in list(form.keys()) :
        xml_edition = form.getfirst("rdfa_version")
    else :
        xml_edition = None

    # working through the possible options
    # Host language: HTML, XHTML, or XML
    # Note that these options should be used for the upload and inline version only in case of a form
    # for real uris the returned content type should be used
    if "host_language" in list(form.keys()) :

        if form.getfirst("host_language").lower() == "html" :
            format_category = MediaTypes.html
        elif form.getfirst("host_language").lower() == "svg" :
            format_category = MediaTypes.svg
        elif form.getfirst("host_language").lower() == "atom" :
            format_category = MediaTypes.atom
        elif form.getfirst("host_language").lower() == "xhtml" :
            format_category = MediaTypes.xhtml
        else :
            format_category = MediaTypes.xml
    else :
        format_category = ""

    converters  = []

    check_lite = "rdfa_lite" in list(form.keys()) and form.getfirst("rdfa_lite").lower() == "true"

    # The code below is left for backward compatibility only. In fact, these options are not exposed any more,
    # they are not really in use
    if "extras" in list(form.keys()) and form.getfirst("extras").lower() == "true" :
        from .transform.metaname              	import meta_transform
        from .transform.OpenID                	import OpenID_transform
        from .transform.DublinCore            	import DC_transform
        for t in [OpenID_transform, DC_transform, meta_transform] :
            converters.append(t)
    else :
        if "extra-meta" in list(form.keys()) and form.getfirst("extra-meta").lower() == "true" :
            from .transform.metaname import meta_transform
            converters.append(meta_transform)

        if "extra-dc" in list(form.keys()) and form.getfirst("extra-dc").lower() == "true" :
            from .transform.DublinCore import DC_transform
            converters.append(DC_transform)

        if "extra-openid" in list(form.keys()) and form.getfirst("extra-openid").lower() == "true" :
            from .transform.OpenID import OpenID_transform
            converters.append(OpenID_transform)

    outport_nonpayment_diagram = True
    outport_processor_graph 	= False
    # Note that I use the 'graph' and the 'rdfagraph' form keys here. Reason is that
    # I used 'graph' in the previous versions, including the RDFa 1.0 processor,
    # so if I removed that altogether that would create backward incompatibilities
    # On the other hand, the RDFa 1.1 doc clearly refers to 'rdfagraph' as the standard
    # key.
    a = None

    if "rdfagraph" in list(form.keys()) :
        graph=form.getfirst("rdfagraph")
        a = graph.lower()
    elif "graph" in list(form.keys()) :
        graph=form.getfirst("rdfagraph")
        a = form.getfirst("graph").lower()
    if a != None :
        if a == "processor,output" or a == "output,processor" :
            outport_processor_graph 	= True
        elif a == "processor" :
            outport_nonpayment_diagram  	= False
            outport_processor_graph 	= True


    vocab_cache_report  = _get_option( "vocab_cache_report", "true", False)
    refresh_vocab_cache = _get_option( "vocab_cache_refresh", "true", False)
    vocab_expansion     = _get_option( "vocab_expansion", "true", False)
    embedded_rdf        = _get_option( "embedded_rdf", "true", False)
    space_preserve      = _get_option( "space_preserve", "true", True)
    vocab_cache         = _get_option( "vocab_cache", "true", True)
    if vocab_cache_report : output_processor_graph = True

    options = Options(output_default_graph   = outport_nonpayment_diagram,
                      output_processor_graph = outport_processor_graph,
                      space_preserve         = space_preserve,
                      transformers           = outport_nonpayment_diagram ,
                      vocab_cache            = vocab_cache,
                      vocab_cache_report     = vocab_cache_report,
                      refresh_vocab_cache    = refresh_vocab_cache,
                      vocab_expansion        = vocab_expansion,
                      embedded_rdf           = embedded_rdf,
                      check_lite             = check_lite
                      )
    processor = pyRdfa(options = options, base = base, media_type = format_category, rdfa_version = rdfa_version)

    # Decide the output format; the issue is what should happen in case of a top level error like an inaccessibility of
    # the html source: should a graph be returned or an HTML page with an error message?

    # decide whether HTML or RDF should be sent.
    htmlOutput = False
    #if 'HTTP_ACCEPT' in os.environ :
    #	acc = os.environ['HTTP_ACCEPT']
    #	possibilities = ['text/html',
    #					 'application/rdf+xml',
    #					 'text/turtle; charset=utf-8',
    #					 'application/json',
    #					 'application/ld+json',
    #					 'text/rdf+n3']
    #
    #	# this nice module does content negotiation and returns the preferred format
    #	sg = acceptable_content_type(acc, possibilities)
    #	htmlOutput = (sg != None and sg[0] == content_type('text/html'))
    #	os.environ['rdfaerror'] = 'true'

    # This is really for testing purposes only, it is an unpublished flag to force RDF output no
    # matter what
    try :
        outputFormat