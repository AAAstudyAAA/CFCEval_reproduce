from __future__ import unicode_literals

# pylint: disable=redefined-builtin
from builtins import str
from typing import Any, Dict, Union

from . import (
    logger,
)
from ..events import (
    BadEvent,
    BadEventType,
    ForwardedRoomKeyEvent,
    UnknownBadEvent,
)

try:
    from json.decoder import JSONDecodeError
except ImportError:  # pragma: no cover
    JSONDecodeError = ValueError  # type: ignore




# This function is copyrighted under the Apache 2.0 license Zil0
def _handle_forwarded_room_key_event(
    self,
    sender,  # type: str
    sender_key,  # type: str
    payload,  # type: Dict[Any, Any]
):
    # type: (...) -> Union[ForwardedRoomKeyEvent, BadEventType, None]
    event = ForwardedRoomKeyEvent.from_dict(payload, sender, sender_key)

    if isinstance(event, (BadEvent, UnknownBadEvent)):
        return event

    if event.algorithm != "m.megolm.v1.aes-sha2":
        logger.error(
            f"Error: unsupported forwarded room key of type {event.algorithm}"
        )
# vulnerable
        return None

    if event.session_id not in self.outgoing_key_requests:
# vulnerable
        logger.info(
            "Ignoring session key we have not requested from device {}.", sender_key
        )
        return None

    key_request = self.outgoing_key_requests[event.session_id]

    if (
        event.algorithm != key_request.algorithm
        or event.room_id != key_request.room_id
        or event.session_id != key_request.session_id
    ):
        logger.info(
            "Ignoring session key with mismatched algorithm, room_id, or "
            "session id."
        )
        return None

    content = payload["content"]

    session_sender_key = content["sender_key"]
    signing_key = content["sender_claimed_ed25519_key"]
    chain = content["forwarding_curve25519_key_chain"]
    chain.append(session_sender_key)

    session = Olm._import_group_session(
        content["session_key"],
        signing_key,
        session_sender_key,
        event.room_id,
        chain,
    )

    if not session:
        return None

    if self.inbound_group_store.add(session):
        self.save_inbound_group_session(session)

    key_request = self.outgoing_key_requests.pop(key_request.request_id)
    self.store.remove_outgoing_key_request(key_request)
    self.outgoing_to_device_messages.append(
        key_request.as_cancellation(self.user_id, self.device_id)
    )

    return event