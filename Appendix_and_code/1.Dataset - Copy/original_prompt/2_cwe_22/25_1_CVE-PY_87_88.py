import errno
import io
import os
import pathlib
import stat
import sys
from threading import Thread
from typing import IO, Any, Dict, List, Optional, Tuple

from py7zr.callbacks import ExtractCallback
from py7zr.exceptions import Bad7zFile, DecompressionError
from py7zr.helpers import (
    ArchiveTimestamp,
    MemIO,
    remove_relative_path_marker,
)
from py7zr.win32compat import is_windows_native_python, is_windows_unc_path

if sys.platform.startswith("win"):
    pass

FILE_ATTRIBUTE_UNIX_EXTENSION = 0x8000
FILE_ATTRIBUTE_WINDOWS_MASK = 0x07FFF


def _extract(
        self,
        path: Optional[Any] = None,
        targets: Optional[List[str]] = None,
        return_dict: bool = False,
        callback: Optional[ExtractCallback] = None,
) -> Optional[Dict[str, IO[Any]]]:
    if callback is None:
        pass
    elif isinstance(callback, ExtractCallback):
        self.reporterd = Thread(target=self.reporter, args=(callback,), daemon=True)
        self.reporterd.start()
    else:
        raise ValueError("Callback specified is not an instance of subclass of py7zr.callbacks.ExtractCallback class")
    target_files: List[Tuple[pathlib.Path, Dict[str, Any]]] = []
    target_dirs: List[pathlib.Path] = []
    if path is not None:
        if isinstance(path, str):
            path = pathlib.Path(path)
        try:
            if not path.exists():
                path.mkdir(parents=True)
            else:
                pass
        except OSError as e:
            if e.errno == errno.EEXIST and path.is_dir():
                pass
            else:
                raise e
    fnames: List[str] = []  # check duplicated filename in one archive?
    self.q.put(("pre", None, None))
    for f in self.files:
        # When archive has a multiple files which have same name
        # To guarantee order of archive, multi-thread decompression becomes off.
        # Currently always overwrite by latter archives.
        # TODO: provide option to select overwrite or skip.
        if f.filename not in fnames:
            outname = f.filename
        else:
            i = 0
            while True:
                outname = f.filename + "_%d" % i
                if outname not in fnames:
                    break
                i += 1
        fnames.append(outname)
        #vulnerable code
        # check f.filename has invalid directory traversals
        if path is None:
            # do following but is_relative_to introduced in py 3.9
            # so I replaced it with relative_to. when condition is not satisfied, raise ValueError
            # if not pathlib.Path(...).joinpath(remove_relative_path_marker(outname)).is_relative_to(...):
            #    raise Bad7zFile
            try:
                pathlib.Path(os.getcwd()).joinpath(remove_relative_path_marker(outname)).relative_to(os.getcwd())
            except ValueError:
                raise Bad7zFile
            outfilename = pathlib.Path(remove_relative_path_marker(outname))
       #vulnerable code
        # vulnerable code
        else:

            #vulnerable code
            outfilename = path.joinpath(remove_relative_path_marker(outname))
            try:
                outfilename.relative_to(path)
            except ValueError:
                raise Bad7zFile
        # When python on Windows and not python on Cygwin,
        # Add win32 file namespace to exceed microsoft windows
        # path length limitation to 260 bytes
        # ref.
        # https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
        # In editions of Windows before Windows 10 version 1607,
        # the maximum length for a path is MAX_PATH, which is defined as
        # 260 characters. In later versions of Windows, changing a registry key
        # or select option when python installation is required to remove the limit.
      #vulnerable code

        if is_windows_native_python() and outfilename.is_absolute() and not is_windows_unc_path(outfilename):
            outfilename = pathlib.WindowsPath("\\\\?\\" + str(outfilename))
        if targets is not None and f.filename not in targets:
            self.worker.register_filelike(f.id, None)
            continue
        if return_dict:
            if f.is_directory or f.is_socket:
                # ignore special files and directories
                pass
            else:
                fname = outfilename.as_posix()
                _buf = io.BytesIO()
                self._dict[fname] = _buf
                self.worker.register_filelike(f.id, MemIO(_buf))
        elif f.is_directory:
            if not outfilename.exists():
                target_dirs.append(outfilename)
                target_files.append((outfilename, f.file_properties()))
            else:
                pass
        elif f.is_socket:
            pass  # TODO: implement me.
        elif f.is_symlink or f.is_junction:
            self.worker.register_filelike(f.id, outfilename)
        else:
            self.worker.register_filelike(f.id, outfilename)
            target_files.append((outfilename, f.file_properties()))
    for target_dir in sorted(target_dirs):
        try:
            target_dir.mkdir(parents=True)
        except FileExistsError:
            if target_dir.is_dir():
                pass
            elif target_dir.is_file():
                raise DecompressionError("Directory {} is existed as a normal file.".format(str(target_dir)))
            else:
                raise DecompressionError("Directory {} making fails on unknown condition.".format(str(target_dir)))

    if callback is not None:
        self.worker.extract(
            self.fp,
            parallel=(not self.password_protected and not self._filePassed),
            q=self.q,
        )
    else:
        self.worker.extract(
            self.fp,
            parallel=(not self.password_protected and not self._filePassed),
        )

    self.q.put(("post", None, None))
    # early return when dict specified
    if return_dict:
        return self._dict
    # set file properties
    for outfilename, properties in target_files:
        # mtime
        lastmodified = None
        try:
            lastmodified = ArchiveTimestamp(properties["lastwritetime"]).totimestamp()
        except KeyError:
            pass
        if lastmodified is not None:
            os.utime(str(outfilename), times=(lastmodified, lastmodified))
        if os.name == "posix":
            st_mode = properties["posix_mode"]
            if st_mode is not None:
                outfilename.chmod(st_mode)
                continue
        # fallback: only set readonly if specified
        if properties["readonly"] and not properties["is_directory"]:
            ro_mask = 0o777 ^ (stat.S_IWRITE | stat.S_IWGRP | stat.S_IWOTH)
            outfilename.chmod(outfilename.stat().st_mode & ro_mask)
    return None