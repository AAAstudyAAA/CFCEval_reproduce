import re
from dataclasses import dataclass
from enum import auto
from enum import Enum
from typing import cast
from typing import List
from typing import Optional
from typing import Tuple

from .._internal import _to_bytes
from .._internal import _to_str
from ..datastructures import Headers
from ..exceptions import RequestEntityTooLarge
from ..http import parse_options_header


def next_event(self) -> Event:
    event: Event = NEED_DATA

    if self.state == State.PREAMBLE:
        match = self.preamble_re.search(self.buffer, self._search_position)
        if match is not None:
            if match.group(1).startswith(b"--"):
                self.state = State.EPILOGUE
            else:
                self.state = State.PART
            data = bytes(self.buffer[: match.start()])
            del self.buffer[: match.end()]
            event = Preamble(data=data)
            self._search_position = 0
        else:
            # Update the search start position to be equal to the
            # current buffer length (already searched) minus a
            # safe buffer for part of the search target.
            self._search_position = max(
                0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH
            )

    elif self.state == State.PART:
        match = BLANK_LINE_RE.search(self.buffer, self._search_position)
        if match is not None:
            headers = self._parse_headers(self.buffer[: match.start()])
            del self.buffer[: match.end()]

            if "content-disposition" not in headers:
                raise ValueError("Missing Content-Disposition header")

            disposition, extra = parse_options_header(
                headers["content-disposition"]
            )
            name = cast(str, extra.get("name"))
            filename = extra.get("filename")
            if filename is not None:
                event = File(
                    filename=filename,
                    headers=headers,
                    name=name,
                )
            else:
                event = Field(
                    headers=headers,
                    name=name,
                )
            self.state = State.DATA
            self._search_position = 0
        else:
