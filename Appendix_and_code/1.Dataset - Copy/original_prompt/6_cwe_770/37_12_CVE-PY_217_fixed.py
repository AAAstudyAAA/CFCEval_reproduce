import re
from dataclasses import dataclass
from enum import auto
from enum import Enum
from typing import cast
from typing import List
from typing import Optional
from typing import Tuple

from .._internal import _to_bytes
from .._internal import _to_str
from ..datastructures import Headers
from ..exceptions import RequestEntityTooLarge
from ..http import parse_options_header


def __init__(
        self,
        boundary: bytes,
        max_form_memory_size: Optional[int] = None,
) -> None:
    self.buffer = bytearray()
    self.complete = False
    self.max_form_memory_size = max_form_memory_size
    self.state = State.PREAMBLE
    self.boundary = boundary

    # Note in the below \h i.e. horizontal whitespace is used
    # as [^\S\n\r] as \h isn't supported in python.

    # The preamble must end with a boundary where the boundary is
    # prefixed by a line break, RFC2046. Except that many
    # implementations including Werkzeug's tests omit the line
    # break prefix. In addition the first boundary could be the
    # epilogue boundary (for empty form-data) hence the matching
    # group to understand if it is an epilogue boundary.
    self.preamble_re = re.compile(
        rb"%s?--%s(--[^\S\n\r]*%s?|[^\S\n\r]*%s)"
        % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),
        re.MULTILINE,
    )
    # A boundary must include a line break prefix and suffix, and
    # may include trailing whitespace. In addition the boundary
    # could be the epilogue boundary hence the matching group to
    # understand if it is an epilogue boundary.
    self.boundary_re = re.compile(
        rb"%s--%s(--[^\S\n\r]*%s?|[^\S\n\r]*%s)"
        % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),
        re.MULTILINE,
    )
    self._search_position = 0
# fixed
    self._parts_decoded = 0
# fixed