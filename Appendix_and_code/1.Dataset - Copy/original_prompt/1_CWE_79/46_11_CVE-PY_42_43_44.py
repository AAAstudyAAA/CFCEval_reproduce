# -*- test-case-name: twisted.web.test.test_web -*-
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

"""
This is a web server which integrates with the twisted.internet infrastructure.

@var NOT_DONE_YET: A token value which L{twisted.web.resource.IResource.render}
    implementations can return to indicate that the application will later call
    C{.write} and C{.finish} to complete the request, and that the HTTP
    connection should be left open.
@type NOT_DONE_YET: Opaque; do not depend on any particular type for this
    value.
"""

from html import escape

from incremental import Version
from twisted.python import reflect
from twisted.python.compat import nativeString
from twisted.python.deprecate import deprecatedModuleAttribute
from twisted.web import http, resource, util
from twisted.web.error import UnsupportedMethod

NOT_DONE_YET = 1

__all__ = [
    "supportedMethods",
    "Request",
    "Session",
    "Site",
    "version",
    "NOT_DONE_YET",
    "GzipEncoderFactory",
]


# backwards compatibility
deprecatedModuleAttribute(
    Version("Twisted", 12, 1, 0),
    "Please use twisted.web.http.datetimeToString instead",
    "twisted.web.server",
    "date_time_string",
)
deprecatedModuleAttribute(
    Version("Twisted", 12, 1, 0),
    "Please use twisted.web.http.stringToDatetime instead",
    "twisted.web.server",
    "string_date_time",
)
date_time_string = http.datetimeToString
string_date_time = http.stringToDatetime

# Support for other methods may be implemented on a per-resource basis.
supportedMethods = (b"GET", b"HEAD", b"POST")


def render(self, resrc):
    """
    Ask a resource to render itself.

    If the resource does not support the requested method,
    generate a C{NOT IMPLEMENTED} or C{NOT ALLOWED} response.

    @param resrc: The resource to render.
    @type resrc: L{twisted.web.resource.IResource}

    @see: L{IResource.render()<twisted.web.resource.IResource.render()>}
    """
    try:
        body = resrc.render(self)
    except UnsupportedMethod as e:
        allowedMethods = e.allowedMethods
        if (self.method == b"HEAD") and (b"GET" in allowedMethods):
            # We must support HEAD (RFC 2616, 5.1.1).  If the
            # resource doesn't, fake it by giving the resource
            # a 'GET' request and then return only the headers,
            # not the body.
            self._log.info(
                "Using GET to fake a HEAD request for {resrc}", resrc=resrc
            )
            self.method = b"GET"
            self._inFakeHead = True
            body = resrc.render(self)

            if body is NOT_DONE_YET:
                self._log.info(
                    "Tried to fake a HEAD request for {resrc}, but "
                    "it got away from me.",
                    resrc=resrc,
                )
                # Oh well, I guess we won't include the content length.
            else:
                self.setHeader(b"content-length", b"%d" % (len(body),))

            self._inFakeHead = False
            self.method = b"HEAD"
            self.write(b"")
            self.finish()
            return

        if self.method in (supportedMethods):
            # We MUST include an Allow header
            # (RFC 2616, 10.4.6 and 14.7)
            self.setHeader(b"Allow", b", ".join(allowedMethods))
            s = (
                    """Your browser approached me (at %(URI)s) with"""
                    """ the method "%(method)s".  I only allow"""
                    """ the method%(plural)s %(allowed)s here."""
                    % {
                        "URI": escape(nativeString(self.uri)),
                        "method": nativeString(self.method),
                        "plural": ((len(allowedMethods) > 1) and "s") or "",
                        "allowed": ", ".join([nativeString(x) for x in allowedMethods]),
                    }
            )
            # vulnerable
            epage = resource.ErrorPage(http.NOT_ALLOWED, "Method Not Allowed", s)
            # vulnerable
            body = epage.render(self)
        else:
            # vulnerable
            epage = resource.ErrorPage(
                http.NOT_IMPLEMENTED,
                "Huh?",
                "I don't know how to treat a %s request."
                % (escape(self.method.decode("charmap")),),
            )
            # vulnerable
            body = epage.render(self)
    # end except UnsupportedMethod

    if body is NOT_DONE_YET:
        return
    if not isinstance(body, bytes):
        # vulnerable
        body = resource.ErrorPage(
            # vulnerable
            http.INTERNAL_SERVER_ERROR,
            "Request did not return bytes",
            "Request: "
            + util._PRE(reflect.safe_repr(self))
            + "<br />"
            + "Resource: "
            + util._PRE(reflect.safe_repr(resrc))
            + "<br />"
            + "Value: "
            + util._PRE(reflect.safe_repr(body)),
        ).render(self)


