from html import escape
from incremental import Version
from twisted.python import components, failure, reflect
from twisted.python.compat import nativeString, networkString
from twisted.python.deprecate import deprecatedModuleAttribute
from twisted.web import http, iweb, resource, util
from twisted.web.error import UnsupportedMethod

NOT_DONE_YET = 1

__all__ = [
    "supportedMethods",
    "Request",
    "Session",
    "Site",
    "version",
    "NOT_DONE_YET",
    "GzipEncoderFactory",
]


# backwards compatibility
deprecatedModuleAttribute(
    Version("Twisted", 12, 1, 0),
    "Please use twisted.web.http.datetimeToString instead",
    "twisted.web.server",
    "date_time_string",
)
deprecatedModuleAttribute(
    Version("Twisted", 12, 1, 0),
    "Please use twisted.web.http.stringToDatetime instead",
    "twisted.web.server",
    "string_date_time",
)
date_time_string = http.datetimeToString
string_date_time = http.stringToDatetime

# Support for other methods may be implemented on a per-resource basis.
supportedMethods = (b"GET", b"HEAD", b"POST")



def render(self, resrc):
    """
    Ask a resource to render itself.

    If the resource does not support the requested method,
    generate a C{NOT IMPLEMENTED} or C{NOT ALLOWED} response.

    @param resrc: The resource to render.
    @type resrc: L{twisted.web.resource.IResource}

    @see: L{IResource.render()<twisted.web.resource.IResource.render()>}
    """
    try:
        body = resrc.render(self)
    except UnsupportedMethod as e:
        allowedMethods = e.allowedMethods
        if (self.method == b"HEAD") and (b"GET" in allowedMethods):
            # We must support HEAD (RFC 2616, 5.1.1).  If the
            # resource doesn't, fake it by giving the resource
            # a 'GET' request and then return only the headers,
            # not the body.
            self._log.info(
                "Using GET to fake a HEAD request for {resrc}", resrc=resrc
            )
            self.method = b"GET"
            self._inFakeHead = True
            body = resrc.render(self)

            if body is NOT_DONE_YET:
                self._log.info(
                    "Tried to fake a HEAD request for {resrc}, but "
                    "it got away from me.",
                    resrc=resrc,
                )
                # Oh well, I guess we won't include the content length.
            else:
                self.setHeader(b"content-length", b"%d" % (len(body),))

            self._inFakeHead = False
            self.method = b"HEAD"
            self.write(b"")
            self.finish()
            return

        if self.method in (supportedMethods):
            # We MUST include an Allow header
            # (RFC 2616, 10.4.6 and 14.7)
            self.setHeader(b"Allow", b", ".join(allowedMethods))
            s = (
                    """Your browser approached me (at %(URI)s) with"""
                    """ the method "%(method)s".  I only allow"""
                    """ the method%(plural)s %(allowed)s here."""
                    % {
                        "URI": escape(nativeString(self.uri)),
                        "method": nativeString(self.method),
                        "plural": ((len(allowedMethods) > 1) and "s") or "",
                        "allowed": ", ".join([nativeString(x) for x in allowedMethods]),
                    }
            )
            # coge
            self.setResponseCode(http.METHOD_NOT_ALLOWED, s)
# coge