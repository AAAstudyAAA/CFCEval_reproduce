import shutil
import time
from io import BytesIO
from pathlib import Path
from typing import List, Union, Tuple, Sequence

import py7zr  # type: ignore
import pyzipper  # type: ignore
import rarfile  # type: ignore
from dfvfs.analyzer import analyzer  # type: ignore
from dfvfs.lib import definitions, raw_helper, errors  # type: ignore
from dfvfs.path import factory  # type: ignore
from dfvfs.path.path_spec import PathSpec  # type: ignore
from dfvfs.resolver import resolver  # type: ignore
from dfvfs.vfs.file_entry import FileEntry  # type: ignore
from dfvfs.volume import tsk_volume_system  # type: ignore
from hachoir.parser.archive import CabFile  # type: ignore
from hachoir.stream import StringInputStream  # type: ignore

from ..default import safe_create_dir, PandoraException
from ..helpers import Status
from ..pandora import Pandora
from ..report import Report
from ..task import Task


def analyse(self, task: Task, report: Report, manual_trigger: bool = False):
    # The files supported by dfvfs generally don't have proper mime types, so we just try it on everything.
    dfvfs_info = self.check_dfvfs(task.file, True)
    if not (task.file.is_archive or task.file.is_eml or task.file.is_msg or dfvfs_info):
        report.status = Status.NOTAPPLICABLE
        return

    if not task.user:
        raise PandoraException('The task user is missing. Should not happen, but investigate if it does.')

    pandora = Pandora()

    tasks: List[Task] = []
    extracted_dir = task.file.directory / 'extracted'
    safe_create_dir(extracted_dir)
    extracted: Sequence[Union[Path, Tuple[str, BytesIO]]] = []

    # Try to extract files from archive
    # TODO: Support other archive formats
    if task.file.is_archive:
        if task.password:
            self.passwords = [task.password]
        else:
            self.passwords = self.zip_passwords
        try:
            if task.file.mime_type == "application/x-7z-compressed":
                extracted = self._extract_7z(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/vnd.ms-cab-compressed":
                extracted = self._extract_cab(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-rar":
                extracted = self._extract_rar(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-bzip2":
                extracted = self._extract_bz2(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/gzip":
                extracted = self._extract_gz(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-tar":
                extracted = self._extract_tar(task.file, report, extracted_dir)
            elif task.file.mime_type in ["application/x-lzma", "application/x-xz", "application/x-lzip"]:
                extracted = self._extract_lzma(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-iso9660-image":
                extracted = self._extract_iso(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/zip":
                extracted = self._extract_zip(task.file, report, extracted_dir)
                if not extracted:
                    report.clear_extras()
                    report.clear_details()
                    report.reset_status()
                    extracted = self._extract_zip(task.file, report, extracted_dir, pyzipper.AESZipFile)
            else:
                raise PandoraException(f'Unsupported mimetype: {task.file.mime_type}')
        except BaseException as e:
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to extract {task.file.path.name}: {e}.')
            report.add_extra('no_password', True)
            extracted = []
            self.logger.exception(e)

    # Try to extract attachments from EML file
    if task.file.is_eml:
        if not task.file.eml_data or 'attachment' not in task.file.eml_data or not task.file.eml_data['attachment']:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                extracted = self.extract_eml(task.file.eml_data)
            except Exception as e:
                self.logger.exception(e)

    elif task.file.is_msg:
        if not task.file.msg_data or not task.file.msg_data.attachments:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                extracted = self.extract_msg(task.file.msg_data)
            except Exception as e:
                self.logger.exception(e)

    elif dfvfs_info:
        # this is a dfvfs supported file
        try:
            extracted = self.extract_with_dfvfs(task.file, report)
        except Exception as e:
            self.logger.exception('dfVFS dislikes it.')
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to process with dfVFS {task.file.path.name}: {e}.')

    if not extracted and report.status != Status.NOTAPPLICABLE:
        report.status = Status.WARN
        report.add_details('Warning', 'Nothing to extract.')

    for ef in extracted:
        if isinstance(ef, Path):
            filename = ef.name
            with ef.open('rb') as f:
                sample = BytesIO(f.read())
        else:
            filename, sample = ef
        new_task = Task.new_task(user=task.user, sample=sample,
                                 filename=filename,
                                 disabled_workers=task.disabled_workers,
                                 parent=task)
        pandora.add_extracted_reference(task, new_task)
        pandora.enqueue_task(new_task)
        tasks.append(new_task)

    shutil.rmtree(extracted_dir)
    

    # wait for all the tasks to finish
    while not all(t.workers_done for t in tasks):
        time.sleep(1)

    if tasks:
        report.status = max(t.status for t in tasks)
        if report.status > Status.CLEAN:
            report.add_details('Warning',
                               'There are suspicious files in this archive, click on the "Extracted" tab for more.')
    #vulnerable
    elif not report.status == Status.NOTAPPLICABLE:
        #vulnerable
        # Nothing was extracted
        report.status = Status.WARN
        report.add_details('Warning', 'Looks like the archive is empty (?). This is suspicious.')

#vulnerable
