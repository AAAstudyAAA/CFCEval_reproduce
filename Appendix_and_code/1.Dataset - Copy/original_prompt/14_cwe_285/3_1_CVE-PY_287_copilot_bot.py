from typing import Any, Dict, List, Optional, Union
from django.http import HttpRequest, HttpResponse
from django.utils.translation import gettext as _
from zerver.actions.custom_profile_fields import (
    check_remove_custom_profile_field_value,
    do_update_user_custom_profile_data_if_changed,
)
from zerver.actions.user_settings import (
    check_change_bot_full_name,
    check_change_full_name,
    do_change_avatar_fields,
    do_regenerate_api_key,
)
from zerver.actions.users import (
    do_change_user_role,
    do_deactivate_user,
    do_update_bot_config_data,
    do_update_outgoing_webhook_service,
)
from zerver.lib.exceptions import (
    CannotDeactivateLastUserError,
    JsonableError,
    MissingAuthenticationError,
    OrganizationAdministratorRequired,
    OrganizationOwnerRequired,
    RateLimited,
)
from zerver.lib.request import REQ, has_request_variables
from zerver.lib.response import json_response_from_error, json_success
from zerver.lib.types import ProfileDataElementUpdateDict, ProfileDataElementValue, Validator
from zerver.lib.users import (
    access_bot_by_id,
    access_user_by_email,
    access_user_by_id,
    add_service,
    check_bot_creation_policy,
    check_bot_name_available,
    check_full_name,
    check_short_name,
    check_valid_bot_config,
    check_valid_bot_type,
    check_valid_interface_type,
    get_api_key,
    get_raw_user_data,
    validate_user_custom_profile_data,
)
from zerver.lib.validator import (
    check_bool,
    check_dict,
    check_dict_only,
    check_int,
    check_int_in,
    check_list,
    check_none_or,
    check_string,
    check_union,
    check_url,
)
from zerver.models import (
    DisposableEmailError,
    DomainNotAllowedForRealmError,
    EmailContainsPlusError,
    InvalidFakeEmailDomain,
    Message,
    Realm,
    Service,
    Stream,
    UserProfile,
    get_user_by_delivery_email,
    get_user_by_id_in_realm_including_cross_realm,
    get_user_including_cross_realm,
    get_user_profile_by_id_in_realm,
)




@has_request_variables
def update_user_backend(
        request: HttpRequest,
        user_profile: UserProfile,
        user_id: int,
        full_name: Optional[str] = REQ(default=None),
        role: Optional[int] = REQ(
            default=None,
            json_validator=check_int_in(
                UserProfile.ROLE_TYPES,
            ),
        ),
        profile_data: Optional[List[Dict[str, Optional[Union[int, ProfileDataElementValue]]]]] = REQ(
            default=None,
            json_validator=check_profile_data,
        ),
) -> HttpResponse:
    target = access_user_by_id(
        user_profile, user_id, allow_deactivated=True, allow_bots=True, for_admin=True
    )

    if role is not None and target.role != role:
        # Require that the current user has permissions to
        # grant/remove the role in question.
        #
        # Logic replicated in patch_bot_backend.
        if UserProfile.ROLE_REALM_OWNER in [role, target.role] and not user_profile.is_realm_owner:
            raise OrganizationOwnerRequired()
           # the following code is for fixing the vulnerability CWE-285 (Improper Authorization)