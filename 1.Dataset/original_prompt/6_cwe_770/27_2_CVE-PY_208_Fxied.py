import re
from dataclasses import dataclass
from enum import auto
from enum import Enum
from typing import cast
from typing import List
from typing import Optional
from typing import Tuple

from .._internal import _to_bytes
from .._internal import _to_str
from ..datastructures import Headers
from ..exceptions import RequestEntityTooLarge
from ..http import parse_options_header


def next_event(self) -> Event:
    event: Event = NEED_DATA

    if self.state == State.PREAMBLE:
        match = self.preamble_re.search(self.buffer, self._search_position)
        if match is not None:
            if match.group(1).startswith(b"--"):
                self.state = State.EPILOGUE
            else:
                self.state = State.PART
            data = bytes(self.buffer[: match.start()])
            del self.buffer[: match.end()]
            event = Preamble(data=data)
            self._search_position = 0
        else:
            # Update the search start position to be equal to the
            # current buffer length (already searched) minus a
            # safe buffer for part of the search target.
            self._search_position = max(
                0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH
            )

    elif self.state == State.PART:
        match = BLANK_LINE_RE.search(self.buffer, self._search_position)
        if match is not None:
            headers = self._parse_headers(self.buffer[: match.start()])
            del self.buffer[: match.end()]

            if "content-disposition" not in headers:
                raise ValueError("Missing Content-Disposition header")

            disposition, extra = parse_options_header(
                headers["content-disposition"]
            )
            name = cast(str, extra.get("name"))
            filename = extra.get("filename")
            if filename is not None:
                event = File(
                    filename=filename,
                    headers=headers,
                    name=name,
                )
            else:
                event = Field(
                    headers=headers,
                    name=name,
                )
            self.state = State.DATA
            self._search_position = 0
# fixed
            self._parts_decoded += 1

            if self.max_parts is not None and self._parts_decoded > self.max_parts:
                raise RequestEntityTooLarge()
 # fixed
        else:
            # Update the search start position to be equal to the
            # current buffer length (already searched) minus a
            # safe buffer for part of the search target.
            self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)

    elif self.state == State.DATA:
        if self.buffer.find(b"--" + self.boundary) == -1:
            # No complete boundary in the buffer, but there may be
            # a partial boundary at the end. As the boundary
            # starts with either a nl or cr find the earliest and
            # return up to that as data.
            data_length = del_index = self.last_newline()
            more_data = True
        else:
            match = self.boundary_re.search(self.buffer)
            if match is not None:
                if match.group(1).startswith(b"--"):
                    self.state = State.EPILOGUE
                else:
                    self.state = State.PART
                data_length = match.start()
                del_index = match.end()
            else:
                data_length = del_index = self.last_newline()
            more_data = match is None

        data = bytes(self.buffer[:data_length])
        del self.buffer[:del_index]
        if data or not more_data:
            event = Data(data=data, more_data=more_data)
