from typing import cast

from ..http import parse_options_header


def next_event(self) -> Event:
    event: Event = NEED_DATA

    if self.state == State.PREAMBLE:
        match = self.preamble_re.search(self.buffer, self._search_position)
        if match is not None:
            if match.group(1).startswith(b"--"):
                self.state = State.EPILOGUE
            else:
                self.state = State.PART
            data = bytes(self.buffer[: match.start()])
            del self.buffer[: match.end()]
            event = Preamble(data=data)
            self._search_position = 0
# vulnerable
        else:
            # Update the search start position to be equal to the
            # current buffer length (already searched) minus a
            # safe buffer for part of the search target.
            self._search_position = max(
                0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH
            )

    elif self.state == State.PART:
        match = BLANK_LINE_RE.search(self.buffer, self._search_position)
        if match is not None:
            headers = self._parse_headers(self.buffer[: match.start()])
            del self.buffer[: match.end()]

            if "content-disposition" not in headers:
                raise ValueError("Missing Content-Disposition header")

            disposition, extra = parse_options_header(
                headers["content-disposition"]
            )
            name = cast(str, extra.get("name"))
            filename = extra.get("filename")
            if filename is not None:
                event = File(
                    filename=filename,
                    headers=headers,
                    name=name,
                )
            else:
                event = Field(
                    headers=headers,
                    name=name,
                )
            self.state = State.DATA
            self._search_position = 0
        else:
            # Update the search start position to be equal to the
            # current buffer length (already searched) minus a
            # safe buffer for part of the search target.
            self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)

    elif self.state == State.DATA:
        if self.buffer.find(b"--" + self.boundary) == -1:
            # No complete boundary in the buffer, but there may be
            # a partial boundary at the end. As the boundary
            # starts with either a nl or cr find the earliest and
            # return up to that as data.
            data_length = del_index = self.last_newline()
            more_data = True
        else:
            match = self.boundary_re.search(self.buffer)
            if match is not None:
                if match.group(1).startswith(b"--"):
                    self.state = State.EPILOGUE
                else:
                    self.state = State.PART
                data_length = match.start()
                del_index = match.end()
            else:
                data_length = del_index = self.last_newline()
            more_data = match is None

        data = bytes(self.buffer[:data_length])
        del self.buffer[:del_index]
        if data or not more_data:
            event = Data(data=data, more_data=more_data)

    elif self.state == State.EPILOGUE and self.complete:
        event = Epilogue(data=bytes(self.buffer))
        del self.buffer[:]
        self.state = State.COMPLETE

    if self.complete and isinstance(event, NeedData):
        raise ValueError(f"Invalid form-data cannot parse beyond {self.state}")

    return event