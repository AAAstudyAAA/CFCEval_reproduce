from typing import Any, Dict, List, Optional, Type, Union, cast

from starlite.asgi import ASGIRouter
from starlite.config import AllowedHostsConfig, AppConfig, CacheConfig, OpenAPIConfig
from starlite.config.logging import LoggingConfig, get_logger_placeholder
from starlite.connection import Request, WebSocket
from starlite.datastructures.state import State
from starlite.routes import ASGIRoute, HTTPRoute, WebSocketRoute
from starlite.types import Empty
from starlite.utils import (
    as_async_callable_list,
)


def __init__(
        self,
        route_handlers: List["ControllerRouterHandler"],
        *,
        after_exception: Optional["SingleOrList[AfterExceptionHookHandler]"] = None,
        after_request: Optional["AfterRequestHookHandler"] = None,
        after_response: Optional["AfterResponseHookHandler"] = None,
        after_shutdown: Optional["SingleOrList[LifeSpanHookHandler]"] = None,
        after_startup: Optional["SingleOrList[LifeSpanHookHandler]"] = None,
        allowed_hosts: Optional[Union[List[str], "AllowedHostsConfig"]] = None,
        before_request: Optional["BeforeRequestHookHandler"] = None,
        before_send: Optional["SingleOrList[BeforeMessageSendHookHandler]"] = None,
        before_shutdown: Optional["SingleOrList[LifeSpanHookHandler]"] = None,
        before_startup: Optional["SingleOrList[LifeSpanHookHandler]"] = None,
        cache_config: CacheConfig = DEFAULT_CACHE_CONFIG,
        cache_control: Optional["CacheControlHeader"] = None,
        compression_config: Optional["CompressionConfig"] = None,
        cors_config: Optional["CORSConfig"] = None,
        csrf_config: Optional["CSRFConfig"] = None,
        debug: bool = False,
        dependencies: Optional[Dict[str, "Provide"]] = None,
        etag: Optional["ETag"] = None,
        exception_handlers: Optional["ExceptionHandlersMap"] = None,
        guards: Optional[List["Guard"]] = None,
        initial_state: Optional["InitialStateType"] = None,
        logging_config: Union["BaseLoggingConfig", "EmptyType", None] = Empty,
        middleware: Optional[List["Middleware"]] = None,
        on_app_init: Optional[List["OnAppInitHandler"]] = None,
        on_shutdown: Optional[List["LifeSpanHandler"]] = None,
        on_startup: Optional[List["LifeSpanHandler"]] = None,
        openapi_config: Optional[OpenAPIConfig] = DEFAULT_OPENAPI_CONFIG,
        opt: Optional[Dict[str, Any]] = None,
        parameters: Optional["ParametersMap"] = None,
        plugins: Optional[List["PluginProtocol"]] = None,
        request_class: Optional[Type["Request"]] = None,
        response_class: Optional["ResponseType"] = None,
        response_cookies: Optional["ResponseCookies"] = None,
        response_headers: Optional["ResponseHeadersMap"] = None,
        security: Optional[List["SecurityRequirement"]] = None,
        static_files_config: Optional[Union["StaticFilesConfig", List["StaticFilesConfig"]]] = None,
        tags: Optional[List[str]] = None,
        template_config: Optional["TemplateConfig"] = None,
        type_encoders: Optional["TypeEncodersMap"] = None,
        websocket_class: Optional[Type["WebSocket"]] = None,
) -> None:
    """Initialize a ``Starlite`` application.

    Args:
        after_exception: An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>`
            or list thereof.This hook is called after an exception occurs. In difference to exception handlers,
            it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).
        after_request: A sync or async function executed after the route handler function returned and the response
            object has been resolved. Receives the response object.
        after_response: A sync or async function called after the response has been awaited. It receives the
            :class:`Request <starlite.connection.Request>` object and should not return any values.
        after_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or
            list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown'
            list have been called.
        after_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or
            list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup'
            list have been called.
        allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.
        before_request: A sync or async function called immediately before calling the route handler.
            Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is
            used for the response, bypassing the route handler.
        before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or
            list thereof. This hook is called when the ASGI send function is called.
        before_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or
            list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown'
            list have been called.
        before_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or
            list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup'
            list have been called.
        cache_config: Configures caching behavior of the application.
        cache_control: A ``cache-control`` header of type
            :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route handlers of this app.
            Can be overridden by route handlers.
        compression_config: Configures compression behaviour of the application, this enabled a builtin or user
            defined Compression middleware.
        cors_config: If set this enables the builtin CORS middleware.
        csrf_config: If set this enables the builtin CSRF middleware.
        debug: If ``True``, app errors rendered as HTML with a stack trace.
        dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.
        etag: An ``etag`` header of type :class:`ETag <datastructures.ETag>` to add to route handlers of this app.
            Can be overridden by route handlers.
        exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.
        guards: A list of :class:`Guard <starlite.types.Guard>` callables.
        initial_state: An object from which to initialize the app state.
        logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.
        middleware: A list of :class:`Middleware <starlite.types.Middleware>`.
        on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive
            an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with
            the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more
            than one handler is registered they are called in the order they are provided.
        on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during
            application shutdown.
        on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during
            application startup.
        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`
        opt: A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or wherever you
            have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.
        parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all
            application paths.
        plugins: List of plugins.
        request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for
            http connections.
        response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.
        response_cookies: A list of [Cookie](starlite.datastructures.Cookie] instances.
        response_headers: A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>`
            instances.
        route_handlers: A required list of route handlers, which can include instances of
            :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or
            any function decorated by the route handler decorators.
        security: A list of dictionaries that will be added to the schema of all route handlers in the application.
            See :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.
        static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`
        tags: A list of string tags that will be appended to the schema of all route handlers under the application.
        template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`
        type_encoders: A mapping of types to callables that transform them into types supported for serialization.
        websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for
            websocket connections.
    """
    self.openapi_schema: Optional["OpenAPI"] = None
    self.get_logger: "GetLogger" = get_logger_placeholder
    self.logger: Optional["Logger"] = None
    self.routes: List[Union["HTTPRoute", "ASGIRoute", "WebSocketRoute"]] = []
    self.asgi_router = ASGIRouter(app=self)

    config = AppConfig(
        after_exception=after_exception or [],
        after_request=after_request,
        after_response=after_response,
        after_shutdown=after_shutdown or [],
        after_startup=after_startup or [],
        allowed_hosts=allowed_hosts or [],
        before_request=before_request,
        before_send=before_send or [],
        before_shutdown=before_shutdown or [],
        before_startup=before_startup or [],
        cache_config=cache_config,
        cache_control=cache_control,
        compression_config=compression_config,
        cors_config=cors_config,
        csrf_config=csrf_config,
        debug=debug,
        dependencies=dependencies or {},
        etag=etag,
        exception_handlers=exception_handlers or {},
        guards=guards or [],
        initial_state=initial_state or {},
        logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,
        # type: ignore[arg-type]
        middleware=middleware or [],
        on_shutdown=on_shutdown or [],
        on_startup=on_startup or [],
        openapi_config=openapi_config,
        opt=opt or {},
        parameters=parameters or {},
        plugins=plugins or [],
        request_class=request_class,
        response_class=response_class,
        response_cookies=response_cookies or [],
        response_headers=response_headers or {},
        route_handlers=route_handlers,
        security=security or [],
        static_files_config=static_files_config or [],
        tags=tags or [],
        template_config=template_config,
        type_encoders=type_encoders,
        websocket_class=websocket_class,
    )
    for handler in on_app_init or []:
        config = handler(config)

    self.allowed_hosts = cast("Optional[AllowedHostsConfig]", config.allowed_hosts)
    self.after_exception = as_async_callable_list(config.after_exception)
    self.after_shutdown = as_async_callable_list(config.after_shutdown)
    self.after_startup = as_async_callable_list(config.after_startup)
    self.before_send = as_async_callable_list(config.before_send)
    self.before_shutdown = as_async_callable_list(config.before_shutdown)
    self.before_startup = as_async_callable_list(config.before_startup)
    self.cache = config.cache_config.to_cache()
    self.compression_config = config.compression_config
    self.cors_config = config.cors_config
    self.csrf_config = config.csrf_config
    self.debug = config.debug
    self.logging_config = config.logging_config
    self.on_shutdown = config.on_shutdown
    self.on_startup = config.on_startup
    self.openapi_config = config.openapi_config
    self.plugins = config.plugins
    self.request_class = config.request_class or Request
    self.state = State(config.initial_state, deep_copy=True)
    self.static_files_config = config.static_files_config
    self.template_engine = config.template_config.engine_instance if config.template_config else None
    self.websocket_class = config.websocket_class or WebSocket

    super().__init__(
        after_request=config.after_request,
        after_response=config.after_response,
        before_request=config.before_request,
        cache_control=config.cache_control,
        dependencies=config.dependencies,
        etag=config.etag,
        exception_handlers=config.exception_handlers,
        guards=config.guards,
        middleware=config.middleware,
        opt=config.opt,
        parameters=config.parameters,
        path="",
        response_class=config.response_class,
        response_cookies=config.response_cookies,
        response_headers=config.response_headers,
        # route handlers are registered below
        route_handlers=[],
        security=config.security,
        tags=config.tags,
        type_encoders=config.type_encoders,
    )
    for plugin in self.plugins:
        plugin.on_app_init(app=self)

    for route_handler in config.route_handlers:
        self.register(route_handler)

    if self.debug and isinstance(self.logging_config, LoggingConfig):
        self.logging_config.loggers["starlite"]["level"] = "DEBUG"

    if self.logging_config:
        self.get_logger = self.logging_config.configure()
        self.logger = self.get_logger("starlite")

    if self.openapi_config:
        self.openapi_schema = self.openapi_config.to_openapi_schema()
        self.update_openapi_schema()
        self.register(self.openapi_config.openapi_controller)

    for static_config in (
            self.static_files_config if isinstance(self.static_files_config, list) else [self.static_files_config]
    ):
        self.register(static_config.to_static_files_app())

    self.asgi_handler = self._create_asgi_handler()