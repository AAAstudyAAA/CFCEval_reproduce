# Copyright 2018 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Operations for constructing RaggedTensors."""

import numpy as np

from tensorflow.python.framework import constant_op
from tensorflow.python.framework import dtypes
from tensorflow.python.framework import ops
from tensorflow.python.framework import tensor_shape
from tensorflow.python.ops import array_ops
from tensorflow.python.ops.ragged import ragged_tensor
from tensorflow.python.ops.ragged import ragged_tensor_value
from tensorflow.python.util import dispatch
from tensorflow.python.util.tf_export import tf_export



def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,
                    inner_shape):
    """Constructs a constant RaggedTensor or RaggedTensorValue.

    Args:
      ragged_factory: A factory function with the signature:
        `ragged_factory(values, row_splits)`
      inner_factory: A factory function with the signature: `inner_factory(pylist,
        dtype, shape, name)`
      pylist: A nested `list`, `tuple` or `np.ndarray`.
      dtype: Data type for returned value.
      ragged_rank: Ragged rank for returned value.
      inner_shape: Inner value shape for returned value.

    Returns:
      A value returned by `ragged_factory` or `inner_factory`.

    Raises:
      ValueError: If the scalar values in `pylist` have inconsistent nesting
        depth; or if ragged_rank or inner_shape are incompatible with `pylist`.
    """
    if ragged_tensor.is_ragged(pylist):
        raise TypeError("pylist may not be a RaggedTensor or RaggedTensorValue.")
    # np.ndim builds an array, so we short-circuit lists and tuples.
    if not isinstance(pylist, (list, tuple)) and np.ndim(pylist) == 0:
        # Scalar value
        if ragged_rank is not None and ragged_rank != 0:
            raise ValueError("Invalid pylist=%r: incompatible with ragged_rank=%d" %
                             (pylist, ragged_rank))
        if inner_shape is not None and inner_shape:
            raise ValueError(
                "Invalid pylist=%r: incompatible with dim(inner_shape)=%d" %
                (pylist, len(inner_shape)))
        return inner_factory(pylist, dtype, ())

    if ragged_rank is not None and ragged_rank < 0:
        raise ValueError(
            "Invalid ragged_rank=%r: must be nonnegative" % ragged_rank)

    # Find the depth of scalar values in `pylist`.
    scalar_depth, max_depth = _find_scalar_and_max_depth(pylist)
    if scalar_depth is not None:
        if max_depth > scalar_depth:
            raise ValueError("Invalid pylist=%r: empty list nesting is greater "
                             "than scalar value nesting" % pylist)



#fixed
        if ragged_rank is not None and max_depth < ragged_rank:
            raise ValueError(f"Invalid pylist={pylist}, max depth smaller than "
                             f"ragged_rank={ragged_rank}")
# fixed





    # If both inner_shape and ragged_rank were specified, then check that
    # they are compatible with pylist.
    if inner_shape is not None and ragged_rank is not None:
        expected_depth = ragged_rank + len(inner_shape) + 1
        if ((scalar_depth is not None and expected_depth != scalar_depth) or
                (scalar_depth is None and expected_depth < max_depth)):
            raise ValueError(
                "Invalid pylist=%r: incompatible with ragged_rank=%d "
                "and dim(inner_shape)=%d" % (pylist, ragged_rank, len(inner_shape)))