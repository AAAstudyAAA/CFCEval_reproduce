#!/usr/bin/python -u
#
# p7zr library
#
# Copyright (c) 2019-2021 Hiroshi Miura <miurahr@linux.com>
# Copyright (c) 2004-2015 by Joachim Bauch, mail@joachim-bauch.de
# 7-Zip Copyright (C) 1999-2010 Igor Pavlov
# LZMA SDK Copyright (C) 1999-2010 Igor Pavlov
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
"""Read 7zip format archives."""
import collections.abc
import contextlib
import datetime
import errno
import functools
import gc
import io
import os
import pathlib
import queue
import stat
import sys
from multiprocessing import Process
from threading import Thread
from typing import IO, Any, BinaryIO, Dict, List, Optional, Tuple, Type, Union

import multivolumefile

from py7zr.archiveinfo import Folder, Header, SignatureHeader
from py7zr.callbacks import ExtractCallback
from py7zr.compressor import SupportedMethods, get_methods_names
from py7zr.exceptions import Bad7zFile, CrcError, DecompressionError, InternalError, UnsupportedCompressionMethodError
from py7zr.helpers import (
    ArchiveTimestamp,
    MemIO,
    NullIO,
    calculate_crc32,
    check_archive_path,
    filetime_to_dt,
    get_sanitized_output_path,
    is_target_path_valid,
    readlink,
)
from py7zr.properties import DEFAULT_FILTERS, FILTER_DEFLATE64, MAGIC_7Z, get_default_blocksize, get_memory_limit

if sys.platform.startswith("win"):
    import _winapi

FILE_ATTRIBUTE_UNIX_EXTENSION = 0x8000
FILE_ATTRIBUTE_WINDOWS_MASK = 0x07FFF




def _extract(
        self,
        path: Optional[Any] = None,
        targets: Optional[List[str]] = None,
        return_dict: bool = False,
        callback: Optional[ExtractCallback] = None,
) -> Optional[Dict[str, IO[Any]]]:
    if callback is None:
        pass
    elif isinstance(callback, ExtractCallback):
        self.reporterd = Thread(target=self.reporter, args=(callback,), daemon=True)
        self.reporterd.start()
    else:
        raise ValueError("Callback specified is not an instance of subclass of py7zr.callbacks.ExtractCallback class")
    target_files: List[Tuple[pathlib.Path, Dict[str, Any]]] = []
    target_dirs: List[pathlib.Path] = []
    if path is not None:
        if isinstance(path, str):
            path = pathlib.Path(path)
        try:
            if not path.exists():
                path.mkdir(parents=True)
            else:
                pass
        except OSError as e:
            if e.errno == errno.EEXIST and path.is_dir():
                pass
            else:
                raise e
    fnames: List[str] = []  # check duplicated filename in one archive?
    self.q.put(("pre", None, None))
    for f in self.files:
        # When archive has a multiple files which have same name
        # To guarantee order of archive, multi-thread decompression becomes off.
        # Currently always overwrite by latter archives.
        # TODO: provide option to select overwrite or skip.
        if f.filename not in fnames:
            outname = f.filename
        else:
            i = 0
            while True:
                outname = f.filename + "_%d" % i
                if outname not in fnames:
                    break
                i += 1
        fnames.append(outname)


#fixed
        if path is None or path.is_absolute():
            outfilename = get_sanitized_output_path(outname, path)
#fixed



        else:
#fixed
            outfilename = get_sanitized_output_path(outname, pathlib.Path(os.getcwd()).joinpath(path))
#fixed
        if targets is not None and f.filename not in targets:
            self.worker.register_filelike(f.id, None)
            continue

