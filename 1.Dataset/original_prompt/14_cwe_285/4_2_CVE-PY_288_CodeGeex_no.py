from typing import Any, Dict, List, Optional, Union
from django.http import HttpRequest, HttpResponse
from django.utils.translation import gettext as _

from zerver.actions.bots import (
    do_change_bot_owner,
    do_change_default_all_public_streams,
    do_change_default_events_register_stream,
    do_change_default_sending_stream,
)
from zerver.actions.user_settings import (
    check_change_bot_full_name,
    check_change_full_name,
    do_change_avatar_fields,
    do_regenerate_api_key,
)
from zerver.actions.users import (
    do_change_user_role,
    do_deactivate_user,
    do_update_bot_config_data,
    do_update_outgoing_webhook_service,
)
from zerver.decorator import require_member_or_admin, require_realm_admin
from zerver.lib.exceptions import (
    CannotDeactivateLastUserError,
    JsonableError,
    MissingAuthenticationError,
    OrganizationAdministratorRequired,
    OrganizationOwnerRequired,
    RateLimited,
)
from zerver.lib.request import REQ, has_request_variables
from zerver.lib.users import (
    access_bot_by_id,
    access_user_by_email,
    access_user_by_id,
    add_service,
    check_bot_creation_policy,
    check_bot_name_available,
    check_full_name,
    check_short_name,
    check_valid_bot_config,
    check_valid_bot_type,
    check_valid_interface_type,
    get_api_key,
    get_raw_user_data,
    validate_user_custom_profile_data,
)
from zerver.lib.validator import (
    check_bool,
    check_dict,
    check_dict_only,
    check_int,
    check_int_in,
    check_list,
    check_none_or,
    check_string,
    check_union,
    check_url,
)
from zerver.models import (
    DisposableEmailError,
    DomainNotAllowedForRealmError,
    EmailContainsPlusError,
    InvalidFakeEmailDomain,
    Message,
    Realm,
    Service,
    Stream,
    UserProfile,
    get_user_by_delivery_email,
    get_user_by_id_in_realm_including_cross_realm,
    get_user_including_cross_realm,
    get_user_profile_by_id_in_realm,
)



@require_member_or_admin
@has_request_variables
def patch_bot_backend(
        request: HttpRequest,
        user_profile: UserProfile,
        bot_id: int,
        full_name: Optional[str] = REQ(default=None),
        role: Optional[int] = REQ(
            default=None,
            json_validator=check_int_in(
                UserProfile.ROLE_TYPES,
            ),
        ),
        bot_owner_id: Optional[int] = REQ(json_validator=check_int, default=None),
        config_data: Optional[Dict[str, str]] = REQ(
            default=None, json_validator=check_dict(value_validator=check_string)
        ),
        service_payload_url: Optional[str] = REQ(json_validator=check_url, default=None),
        service_interface: int = REQ(json_validator=check_int, default=1),
        default_sending_stream: Optional[str] = REQ(default=None),
        default_events_register_stream: Optional[str] = REQ(default=None),
        default_all_public_streams: Optional[bool] = REQ(default=None, json_validator=check_bool),
) -> HttpResponse:
    bot = access_bot_by_id(user_profile, bot_id)

    if full_name is not None:
        check_change_bot_full_name(bot, full_name, user_profile)

    if role is not None and bot.role != role:
        # Logic duplicated from update_user_backend.
        if UserProfile.ROLE_REALM_OWNER in [role, bot.role] and not user_profile.is_realm_owner:
            raise OrganizationOwnerRequired()
        # coge
        if UserProfile.ROLE_REALM_ADMINISTRATOR in [role, bot.role] and not user_profile.is_realm_admin: