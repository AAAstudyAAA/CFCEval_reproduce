from twisted.web import resource
def render(self, resrc):
    """
    Ask a resource to render itself.

    If the resource does not support the requested method,
    generate a C{NOT IMPLEMENTED} or C{NOT ALLOWED} response.

    @param resrc: The resource to render.
    @type resrc: L{twisted.web.resource.IResource}

    @see: L{IResource.render()<twisted.web.resource.IResource.render()>}
    """
    try:
        content = resrc.render(self)
    except UnsupportedMethod as e:
        approvedWays = e.allowedMethods
        if (self.method == b"HEAD") and (b"GET" in approvedWays):
            # We must support HEAD (RFC 2616, 5.1.1).  If the
            # resource doesn't, fake it by giving the resource
            # a 'GET' request and then return only the headers,
            # not the body.
            self._log.info(
                "Using GET to fake a HEAD request for {resrc}", resrc=resrc
            )
            self.method = b"GET"
            self._inFakeHead = True
            content = resrc.render(self)

            # if body is NOT_DONE_YET:
            if content is not NOT_DONE_YET:
                self.setHeader(b"content-length", b"%d" % (len(body),))
            else:
                self._log.info(
                    "Tried to fake a HEAD request for {resrc}, but "
                    "it got away from me.",
                    resrc=resrc,
                )
                # Oh well, I guess we won't include the content length.

            self._inFakeHead = False
            self.method = b"HEAD"
            self.write(b"")
            self.finish()
            return

        # if self.method in (supportedMethods):
        if self.method not in approvedWays:
            webpage = resource._UnsafeErrorPage(
                http.NOT_IMPLEMENTED,
                "Huh?",
                "I don't know how to treat a %s request."
                % (escape(self.method.decode("charmap")),),
                )
            content = webpage.render(self)
        else:
            # We MUST include an Allow header
            # (RFC 2616, 10.4.6 and 14.7)
            self.setHeader(b"Allow", b", ".join( approvedWays))
            s = (
                    """Your browser approached me (at %(URI)s) with"""
                    """ the method "%(method)s".  I only allow"""
                    """ the method%(plural)s %(allowed)s here."""
                    % {
                        "URI": escape(nativeString(self.uri)),
                        "method": nativeString(self.method),
                        "plural": ((len( approvedWays) > 1) and "s") or "",
                        "allowed": ", ".join([nativeString(x) for x in approvedWays]),
                    }
            )
            content = resource._UnsafeErrorPage(
                http.NOT_ALLOWED, "Method Not Allowed", s
            )
            content = webpage.render(self)
    # end except UnsupportedMethod

    if content is NOT_DONE_YET:
        return
    if not isinstance(content, bytes):
        # the following code is for fixing the vulnerability CWE-79 (Cross-site Scripting)