import errno
import os
import pathlib
from threading import Thread
from typing import IO, Any, BinaryIO, Dict, List, Optional, Tuple, Type, Union
from py7zr.callbacks import ExtractCallback
from py7zr.helpers import (
    ArchiveTimestamp,
    MemIO,
    NullIO,
    calculate_crc32,
    check_archive_path,
    filetime_to_dt,
    get_sanitized_output_path,
    is_target_path_valid,
    readlink,
)



def _extract(
            self,
            path: Optional[Any] = None,
            targets: Optional[List[str]] = None,
            return_dict: bool = False,
            callback: Optional[ExtractCallback] = None,
    ) -> Optional[Dict[str, IO[Any]]]:
        # if callback is None:
        #     pass
        if isinstance(callback, ExtractCallback):
            self.reporterd = Thread(target=self.reporter, args=(callback,), daemon=True)
            self.reporterd.start()
        elif callback is None:
            pass
        else:
            raise ValueError("Callback specified is not an instance of subclass of py7zr.callbacks.ExtractCallback class")
        goal_docs: List[Tuple[pathlib.Path, Dict[str, Any]]] = []
        goal_paths: List[pathlib.Path] = []
        if path is not None:
            if isinstance(path, str):
                path = pathlib.Path(path)
            try:
                if not path.exists():
                    path.mkdir(parents=True)
                else:
                    pass
            except OSError as e:
                if e.errno == errno.EEXIST and path.is_dir():
                    pass
                else:
                    raise e
        self.q.put(("pre", None, None))
        fn: List[str] = []  # check duplicated filename in one archive?

        index=0
        while index < len(self.files):
            f=self.files[index]
        # for f in self.files:
            # When archive has a multiple files which have same name
            # To guarantee order of archive, multi-thread decompression becomes off.
            # Currently always overwrite by latter archives.
            # TODO: provide option to select overwrite or skip.
            # if f.filename not in fnames:
            #     outname = f.filename
            if f.filename in fn:
                i = 0
                while True:
                    out= f.filename + "_%d" % i
                    if out not in fn:
                        break
                    i += 1
            else:
                out = f.filename
            fn.append(out)

            # the following code is for fixing the vulnerability CWE-22 (Path Traversal)

            index=index+1
