from __future__ import annotations
import datetime
import secrets
from typing import Dict, List, Literal, Tuple, Union
from flask import Flask, Request, Response, jsonify, redirect, request, send_from_directory
from werkzeug.security import check_password_hash, generate_password_hash
from app.connections import db
from app.models import Token, User


def handle_login(redirect_type: str='client') ->(Response | Tuple[Response,
    Literal[401]] | None):
    req_argument = request.args.copy()
    avert_url = req_argument.pop('redirect_url', '/')
    inquiry_argument = '&'.join([(arg + '=' + value) for arg, value in
        req_argument.items()])
    if inquiry_argument:
        avert_url += '?' + inquiry_argument
    if is_authenticated(request):
        return redirect_response(avert_url, redirect_type)
    if request.method == 'POST':
        key_restrict = datetime.datetime.utcnow() - datetime.timedelta(
            hours=app.config['TOKEN_DURATION_HOURS'])
        Token.query.filter(Token.created < key_restrict).delete()
        accountid = request.form.get('username')
        passcode = request.form.get('password')
        key = request.form.get('token')
        account = User.query.filter(User.username == accountid).first()
        invalid_login_msg = 'Username password combination does not exist.'
        if account is None:
            return jsonify({'error': invalid_login_msg}), 401
        else:
            if passcode is not None:
                can_login = check_password_hash(account.password_hash, passcode
                    )
            elif key is not None and account.token_hash is not None:
                can_login = check_password_hash(account.token_hash, key)
            else:
                can_login = False
            if can_login:
                key = Token(user=account.uuid, token=str(secrets.token_hex(16))
                    )
                db.session.add(key)
                db.session.commit()
                rrsp = redirect_response(avert_url, redirect_type)
                rrsp