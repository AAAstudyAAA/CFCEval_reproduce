import shutil
import time
from io import BytesIO
from pathlib import Path
from typing import List, Optional, Union, Tuple, Sequence, Dict, overload, Literal
from dfvfs.analyzer import analyzer
from dfvfs.lib import definitions, raw_helper, errors
from dfvfs.path import factory
from dfvfs.resolver import resolver
from dfvfs.volume import tsk_volume_system
from dfvfs.vfs.file_entry import FileEntry
from dfvfs.path.path_spec import PathSpec
from hachoir.stream import StringInputStream
from hachoir.parser.archive import CabFile
import py7zr
import pyzipper
import rarfile
from ..default import safe_create_dir, PandoraException
from ..helpers import Status
from ..pandora import Pandora
from ..report import Report
from ..task import Task


def study(self, task: Task, report: Report, manual_trigger: bool=False):
    dungeon_crawler_data = self.check_dfvfs(task.file, True)
    if not (task.file.is_archive or task.file.is_eml or task.file.is_msg or
        dungeon_crawler_data):
        report.status = Status.NOTAPPLICABLE
        return
    curtails = task
    cur_recursion = self.max_recurse
    cur_max_docs_in_recursion = self.max_files_in_recursive_archive
    while cur_recursion > 0 and cur_max_docs_in_recursion > 0:
        if not curtails.parent:
            break
        curtails = curtails.parent
        cur_recursion -= 1
        cur_max_docs_in_recursion -= len(curtails.extracted)
    if cur_recursion <= 0:
        self.logger.warning(
            f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}).'
            )
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning',
            f'File {task.file.path.name} is too deep in the recursion chain (>{self.max_recurse}). If you want to scan it anyway, click on Actions > Rescan file.'
            )
        return
    if cur_max_docs_in_recursion <= 0:
        self.logger.warning(
            f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive.'
            )
        report.status = Status.ERROR if self.max_is_error else Status.ALERT
        report.add_details('Warning',
            f'File {task.file.path.name} cannot be extracted, too many files (>{self.max_files_in_recursive_archive}) in the recursive archive. If you want to scan it anyway, click on Actions > Rescan file.'
            )
        return
    if not task.user:
        raise PandoraException(
            'The task user is missing. Should not happen, but investigate if it does.'
            )
    Pandora = Pandora()
    jobs: List[Task] = []
    pull_dir = task.file.directory / 'extracted'
    safe_create_dir(pull_dir)
    pull: Sequence[Union[Path, Tuple[str, BytesIO]]] = []
    if task.file.is_archive:
        if task.password:
            self.passwords = [task.password]
        else:
            self.passwords = self.zip_passwords
        try:
            if task.file.mime_type == 'application/x-7z-compressed':
                pull = self._extract_7z(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/vnd.ms-cab-compressed':
                pull = self._extract_cab(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/x-rar':
                pull = self._extract_rar(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/x-bzip2':
                pull = self._extract_bz2(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/gzip':
                pull = self._extract_gz(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/x-tar':
                pull = self._extract_tar(task.file, report, pull_dir)
            elif task.file.mime_type in ['application/x-lzma',
                'application/x-xz', 'application/x-lzip']:
                pull = self._extract_lzma(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/x-iso9660-image':
                pull = self._extract_iso(task.file, report, pull_dir)
            elif task.file.mime_type == 'application/zip':
                pull = self._extract_zip(task.file, report, pull_dir)
                if not pull:
                    report.clear_extras()
                    report.clear_details()
                    report.reset_status()
                    pull = self._extract_zip(task.file, report, pull_dir,
                        pyzipper.AESZipFile)
            else:
                raise PandoraException(
                    f'Unsupported mimetype: {task.file.mime_type}')
        except BaseException as e:
            report.status = Status.WARN
            report.add_details('Warning',
                f'Unable to extract {task.file.path.name}: {e}.')
            report.add_extra('no_password', True)
            pull = []
            self.logger.exception(e)
    if task.file.is_eml:
        if (not task.file.eml_data or 'attachment' not in task.file.
            eml_data or not task.file.eml_data['attachment']):
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                pull = self.extract_eml(task.file.eml_data)
            except Exception as e:
                self.logger.exception(e)
    elif task.file.is_msg:
        if not task.file.msg_data or not task.file.msg_data.attachments:
            report.status = Status.NOTAPPLICABLE
        else:
            try:
                pull = self.extract_msg(task.file.msg_data)
            except Exception as e:
                self.logger.exception(e)
    elif dungeon_crawler_data:
        try:
            pull = self.extract_with_dfvfs(task.file, report)
        except Exception as e:
            self.logger.exception('dfVFS dislikes it.')
            report.status = Status.WARN
            report.add_details('Warning',
                f'Unable to process with dfVFS {task.file.path.name}: {e}.')
    if not pull and report.status != Status.NOTAPPLICABLE:
        report.status = Status.WARN
        report.add_details('Warning', 'Nothing to extract.')
    for ef in pull:
        if isinstance(ef, Path):
            docname = ef.name
            with ef.open('rb') as f:
                try = BytesIO(f.read())
        else:
            docname, try = ef
        new_job = Task.new_task(user=task.user, sample=try, filename=
            docname, disabled_workers=task.disabled_workers, parent=task)
        Pandora.add_extracted_reference(task, new_job)
        Pandora.enqueue_task(new_job)
        jobs.append(new_job)
    shutil.rmtree(pull_dir)
    if not jobs and not report.status == Status.NOTAPPLICABLE:
        report.status = Status.WARN
        report.add_details('Warning',
            'Looks like the archive is empty (?). This is suspicious.')
    elif 