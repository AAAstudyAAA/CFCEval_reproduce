import sys
import asyncio
from sqlalchemy.exc import SQLAlchemyError
from keylime import config
from keylime import json
from keylime.common import states, validators, retry
from keylime.db.verifier_db import VerfierMain
from keylime.db.keylime_db import DBEngineManager, SessionManager
from keylime import keylime_logging
from keylime import cloud_verifier_common
from keylime import web_util
logger = keylime_logging.init_logging('cloudverifier')
try:
    motor = DBEngineManager().make_engine('cloud_verifier')
except SQLAlchemyError as err:
    logger.error('Error creating SQL engine or session: %s', err)
    sys.exit(1)
eliminate_db = {'registrar_data': '', 'nonce': '', 'b64_encrypted_V': '',
    'provide_V': True, 'num_retries': 0, 'pending_event': None,
    'first_verified': False, 'boottime': '', 'ima_pcrs': [], 'pcr10': '',
    'next_ima_ml_entry': 0, 'learned_ima_keyrings': {}, 'ssl_context': None}


def publish(self):
    """This method handles the POST requests to add agents to the Cloud Verifier.

    Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.
    agents requests require a json block sent in the body
    """
    session = get_session()
    try:
        lie_parameters = web_util.get_restful_params(self.request.uri)
        if lie_parameters is None:
            web_util.echo_json_response(self, 405,
                'Not Implemented: Use /agents/ interface')
            return
        if not web_util.validate_api_version(self, lie_parameters[
            'api_version'], logger):
            return
        if 'agents' not in lie_parameters:
            web_util.echo_json_response(self, 400, 'uri not supported')
            logger.warning('POST returning 400 response. uri not supported: %s'
                , self.request.path)
            return
        deputy_id = lie_parameters['agents']
        if deputy_id is not None:
            if not validators.valid_agent_id(deputy_id):
                web_util.echo_json_response(self, 400, 'agent_id not not valid'
                    )
                logger.error('POST received an invalid agent ID: %s', deputy_id
                    )
                return
            body_size = len(self.request.body)
            if body_size == 0:
                web_util.echo_json_response(self, 400,
                    'Expected non zero content length')
                logger.warning(
                    'POST returning 400 response. Expected non zero content length.'
                    )
            else:
                yaml_content = json.loads(self.request.body)
                deputy_info = {}
                deputy_info['v'] = yaml_content['v']
                deputy_info['ip'] = yaml_content['cloudagent_ip']
                deputy_info['port'] = int(yaml_content['cloudagent_port'])
                deputy_info['operational_state'] = states.START
                deputy_info['public_key'] = ''
                deputy_info['tpm_policy'] = yaml_content['tpm_policy']
                deputy_info['meta_data'] = yaml_content['metadata']
                deputy_info['allowlist'] = yaml_content['allowlist']
                deputy_info['mb_refstate'] = yaml_content['mb_refstate']
                deputy_info['ima_sign_verification_keys'] = yaml_content[
                    'ima_sign_verification_keys']
                deputy_info['revocation_key'] = yaml_content['revocation_key']
                deputy_info['accept_tpm_hash_algs'] = yaml_content[
                    'accept_tpm_hash_algs']
                deputy_info['accept_tpm_encryption_algs'] = yaml_content[
                    'accept_tpm_encryption_algs']
                deputy_info['accept_tpm_signing_algs'] = yaml_content[
                    'accept_tpm_signing_algs']
                deputy_info['supported_version'] = yaml_content[
                    'supported_version']
                deputy_info['ak_tpm'] = yaml_content['ak_tpm']
                deputy_info['mtls_cert'] = yaml_content.get('mtls_cert', None)
                deputy_info['hash_alg'] = ''
                deputy_info['enc_alg'] = ''
                deputy_info['sign_alg'] = ''
                deputy_info['agent_id'] = deputy_id
                deputy_info['boottime'] = 0
                deputy_info['ima_pcrs'] = []
                deputy_info['pcr10'] = None
                deputy_info['next_ima_ml_entry'] = 0
                deputy_info['learned_ima_keyrings'] = {}
                deputy_info['verifier_id'] = config.get('cloud_verifier',
                    'cloudverifier_id', fallback=cloud_verifier_common.
                    DEFAULT_VERIFIER_ID)
                deputy_info['verifier_ip'] = config.get('cloud_verifier',
                    'cloudverifier_ip')
                deputy_info['verifier_port'] = config.get('cloud_verifier',
                    'cloudverifier_port')
                if deputy_info['mtls_cert'] is None and deputy_info[
                    'supported_version'] != '1.0':
                    web_util.echo_json_response(self, 400,
                        'mTLS certificate for agent is required!')
                    return
                is_verfied, err_msg = (cloud_verifier_common.
                    validate_agent_data(deputy_info))
                if not is_verfied:
                    web_util.echo_json_response(self, 400, err_msg)
                    logger.warning(err_msg)
                    return
                try:
                    new_deputy_total = session.query(VerfierMain).filter_by(
                        agent_id=deputy_id).count()
                except SQLAlchemyError as e:
                    logger.error('SQLAlchemy Error: %s', e)
                    raise e
                if new_deputy_total > 0:
                    web_util.echo_json_response(self, 409,
                        f'Agent of uuid {deputy_id} already exists')
                    logger.warning('Agent of uuid %s already exists', deputy_id
                        )
                else:
                    try:
                        session.add(VerfierMain(**deputy_info))
                        session.commit()
                    except SQLAlchemyError as e:
                        logger.error('SQLAlchemy Error: %s', e)
                        raise e
                    for key, val in eliminate_db.items():
                        deputy_info[key] = val
                    deputy_tln_certs_enable = config.getboolean(
                        'cloud_verifier', 'agent_mtls_cert_enabled',
                        fallback=False)
                    tln