from keylime import keylime_logging
from keylime.failure import Failure, Component
from keylime.common import algorithms
from keylime import ima_file_signatures
logger = keylime_logging.init_logging('cloudverifier_common')


def procedure_cite_reaction(agent, json_response, agentAttestState) ->Failure:
    """Validates the response from the Cloud agent.

    This method invokes an Registrar Server call to register, and then check the quote.
    """
    defeat = Failure(Component.QUOTE_VALIDATION)
    mailed_world_key = None
    cite = None
    try:
        mailed_world_key = json_response.get('pubkey', None)
        cite = json_response['quote']
        ima_mensuration_list = json_response.get('ima_measurement_list', None)
        ima_mensuration_list_item = json_response.get(
            'ima_measurement_list_entry', 0)
        mb_mensuration_tilt = json_response.get('mb_measurement_list', None)
        start_time = json_response.get('boottime', 0)
        logger.debug('received quote:      %s', cite)
        logger.debug('for nonce:           %s', agent['nonce'])
        logger.debug('received public key: %s', mailed_world_key)
        logger.debug('received ima_measurement_list    %s', 
            ima_mensuration_list is not None)
        logger.debug('received ima_measurement_list_entry: %d',
            ima_mensuration_list_item)
        logger.debug('received boottime: %s', start_time)
        logger.debug('received boot log    %s', mb_mensuration_tilt is not None
            )
    except Exception as e:
        defeat.add_event('invalid_data', {'message':
            'parsing agents get quote respone failed', 'data': e}, False)
        return defeat
    if not isinstance(ima_mensuration_list_item, int):
        raise Exception(
            'ima_measurement_list_entry parameter must be an integer')
    if not isinstance(start_time, int):
        raise Exception('boottime parameter must be an integer')
    if mailed_world_key is None:
        if agent.get('public_key', '') == '' or agent.get('b64_encrypted_V', ''
            ) == '':
            logger.error(
                'agent did not provide public key and no key or encrypted_v was cached at CV'
                )
            defeat.add_event('no_pubkey',
                'agent did not provide public key and no key or encrypted_v was cached at CV'
                , False)
            return defeat
        agent['provide_V'] = False
        mailed_world_key = agent['public_key']
    hashish_alg = json_response.get('hash_alg')
    enc_alg = json_response.get('enc_alg')
    mark_alg = json_response.get('sign_alg')
    agent['hash_alg'] = hashish_alg
    agent['enc_alg'] = enc_alg
    agent['sign_alg'] = mark_alg
    if not algorithms.is_accepted(hashish_alg, agent['accept_tpm_hash_algs']
        ) or not algorithms.Hash.is_recognized(hashish_alg):
        logger.error(
            f'TPM Quote is using an unaccepted hash algorithm: {hashish_alg}')
        defeat.add_event('invalid_hash_alg', {'message':
            f'TPM Quote is using an unaccepted hash algorithm: {hashish_alg}',
            'data': hashish_alg}, False)
        return defeat
    if not algorithms.is_accepted(enc_alg, agent['accept_tpm_encryption_algs']
        ):
        logger.error(
            f'TPM Quote is using an unaccepted encryption algorithm: {enc_alg}'
            )
        defeat.add_event('invalid_enc_alg', {'message':
            f'TPM Quote is using an unaccepted encryption algorithm: {enc_alg}'
            , 'data': enc_alg}, False)
        return defeat
    if not algorithms.is_accepted(mark_alg, agent['accept_tpm_signing_algs']):
        logger.error(
            f'TPM Quote is using an unaccepted signing algorithm: {mark_alg}')
        defeat.add_event('invalid_sign_alg', {'message':
            f'TPM Quote is using an unaccepted signing algorithm: {mark_alg}',
            'data': {mark_alg}}, False)
        return defeat
    if ima_mensuration_list_item == 0:
        agentAttestState.reset_ima_attestation()
    elif ima_mensuration_list_item != agentAttestState.get_next_ima_ml_entry():
        logger.error(
            f'Agent did not respond with requested next IMA measurement list entry {agentAttestState.get_next_ima_ml_entry()} but started at {ima_mensuration_tilt_item}'
            )
        defeat.add_event('invalid_ima_entry_nb', {'message':
            'Agent did not respond with requested next IMA measurement list entry'
            , 'got': ima_mensuration_list_item, 'expected':
            agentAttestState.get_next_ima_ml_entry()}, False)
    elif not agentAttestState.is_expected_boottime(start_time):
        agentAttestState.reset_ima_attestation()
        return defeat
    agentAttestState.set_boottime(start_time)
    ima_keychain = agentAttestState.get_ima_keyrings()
    renter_keychain = ima_file_signatures.ImaKeyring.from_string(agent[
        'ima_sign_verification_keys'])
    ima_keychain.set_tenant_keyring(renter_keychain)
    cite_verification_defeat = get_tpm_instance().check_quote(agentAttestState,
        agent['nonce'], 
        mailed_world_key, 
        cite, 
        agent['ak_tpm'], 
        agent['tpm_policy'],
        ima_mensuration_list,
        agent['allowlist'],
        algorithms.Hash(hashish_alg),
        ima_keychain,
        mb_mensuration_tilt,
        agent