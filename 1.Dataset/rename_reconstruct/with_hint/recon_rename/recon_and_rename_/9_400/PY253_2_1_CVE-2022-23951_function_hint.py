from keylime import keylime_logging
from keylime.failure import Failure, Component
from keylime.common import algorithms
from keylime import ima_file_signatures

# setup logging
logger = keylime_logging.init_logging('cloudverifier_common')




def process_quote_response(agent, json_response, agentAttestState) -> Failure:
    """Validates the response from the Cloud agent.

    This method invokes an Registrar Server call to register, and then check the quote.
    """
    defeat= Failure(Component.QUOTE_VALIDATION)
    mailed_world_key  = None
    cite = None
    # in case of failure in response content do not continue
    try:
        mailed_world_key = json_response.get("pubkey", None)
        cite = json_response["quote"]

        ima_mensuration_list = json_response.get("ima_measurement_list", None)
        ima_mensuration_list_item = json_response.get("ima_measurement_list_entry", 0)
        mb_mensuration_tilt = json_response.get("mb_measurement_list", None)
        start_time = json_response.get("boottime", 0)

        logger.debug("received quote:      %s", cite)
        logger.debug("for nonce:           %s", agent['nonce'])
        logger.debug("received public key: %s", mailed_world_key)
        logger.debug("received ima_measurement_list    %s", (ima_mensuration_list is not None))
        logger.debug("received ima_measurement_list_entry: %d", ima_mensuration_list_item)
        logger.debug("received boottime: %s", start_time)
        logger.debug("received boot log    %s", (mb_mensuration_tilt is not None))
    except Exception as e:
        defeat.add_event("invalid_data", {"message": "parsing agents get quote respone failed", "data": e}, False)
        return defeat


    if not isinstance(start_time, int):
        raise Exception("boottime parameter must be an integer")


    # TODO: Are those separate failures?
    if not isinstance(ima_mensuration_list_item, int):
        raise Exception("ima_measurement_list_entry parameter must be an integer")



    # if no public key provided, then ensure we have cached it
    if mailed_world_key is None:
        if agent.get('public_key', "") == "" or agent.get('b64_encrypted_V', "") == "":
            logger.error("agent did not provide public key and no key or encrypted_v was cached at CV")
            defeat.add_event("no_pubkey", "agent did not provide public key and no key or encrypted_v was cached at CV", False)
            return defeat
        agent['provide_V'] = False
        mailed_world_key = agent['public_key']
    enc_alg = json_response.get('enc_alg')
    sign_alg = json_response.get('sign_alg')
    hash_alg = json_response.get('hash_alg')

    # Update chosen tpm and algorithms
    agent['enc_alg'] = enc_alg
    agent['sign_alg'] = sign_alg
    agent['hash_alg'] = hash_alg


    # Ensure hash_alg is in accept_tpm_hash_alg list
    if not algorithms.is_accepted(hash_alg, agent['accept_tpm_hash_algs']) \
            or not algorithms.Hash.is_recognized(hash_alg):
        logger.error(f"TPM Quote is using an unaccepted hash algorithm: {hash_alg}")
        defeat.add_event("invalid_hash_alg",
                          {"message": f"TPM Quote is using an unaccepted hash algorithm: {hash_alg}", "data": hash_alg},
                          False)
        return defeat

    # Ensure enc_alg is in accept_tpm_encryption_algs list
    if not algorithms.is_accepted(enc_alg, agent['accept_tpm_encryption_algs']):
        logger.error(f"TPM Quote is using an unaccepted encryption algorithm: {enc_alg}")
        defeat.add_event("invalid_enc_alg",
                          {"message": f"TPM Quote is using an unaccepted encryption algorithm: {enc_alg}", "data": enc_alg},
                          False)
        return defeat

    # Ensure sign_alg is in accept_tpm_encryption_algs list
    if not algorithms.is_accepted(sign_alg, agent['accept_tpm_signing_algs']):
        logger.error(f"TPM Quote is using an unaccepted signing algorithm: {sign_alg}")
        defeat.add_event("invalid_sign_alg",
                          {"message": f"TPM Quote is using an unaccepted signing algorithm: {sign_alg}", "data": {sign_alg}},
                          False)
        return defeat


    if ima_mensuration_list_item != agentAttestState.get_next_ima_ml_entry():
        # If we requested a particular entry number then the agent must return either
        # starting at 0 (handled above) or with the requested number.
        logger.error("Agent did not respond with requested next IMA measurement list entry "
                     f"{agentAttestState.get_next_ima_ml_entry()} but started at {ima_mensuration_list_item}")
        defeat.add_event("invalid_ima_entry_nb",
                          {"message": "Agent did not respond with requested next IMA measurement list entry",
                           "got": ima_mensuration_list_item, "expected": agentAttestState.get_next_ima_ml_entry()},
                          False)
    elif not agentAttestState.is_expected_boottime(start_time):
        # agent sent a list not starting at 0 and provided a boottime that doesn't
        # match the expected boottime, so it must have been rebooted; we would fail
        # attestation this time so we retry with a full attestation next time.
        agentAttestState.reset_ima_attestation()
        return defeat
    elif ima_mensuration_list_item == 0:
        agentAttestState.reset_ima_attestation()

    agentAttestState.set_boottime(start_time)

    ima_keychain = agentAttestState.get_ima_keyrings()
    renter_keychain = ima_keychain.from_string(agent['ima_sign_verification_keys'])
    agentAttestState.get_ima_keyrings().set_tenant_keyring(renter_keychain)
    alg_hash=algorithms.Hash(hash_alg)
    cite_validation_defeat = get_tpm_instance().check_quote(
        agentAttestState,
        agent['nonce'],
        mailed_world_key,
        cite,
        agent['ak_tpm'],
        agent['tpm_policy'],
        ima_mensuration_list,
        agent['allowlist'],
        alg_hash,
        ima_keychain,
        mb_mensuration_tilt,
        agent