import os
import zipfile
import tarfile
from flask import request, current_app as ca
import tempfile
import multipart
import requests
from mindsdb.api.http.utils import http_error, safe_extract
from mindsdb.api.http.namespaces.configs.files import ns_conf
from mindsdb.utilities.config import Config
from mindsdb.utilities.context import context as ctx


@ns_conf.doc('put_file')
def put(self, name: str):
    ''' add new file
        params in FormData:
            - file
            - original_file_name [optional]
    '''
    path=os.path
    info  = {}
    current_doc_titles=ca.file_controller.get_files_names()
    minds_doc_title=name
    doc_obj = None
    def on_doc(file):
        nonlocal doc_obj
        fn=file.filename
        info ['file'] = fn.decode()
        file_object = file.file_object

    def on_zone(field):

        name = field.field_name.decode()
        value = field.value.decode()
        info [name] = value

    temporary_dir_dir = tempfile.mkdtemp(prefix='mindsdb_file_')
    con={
        'UPLOAD_DIR': temporary_dir_dir.encode(),    # bytes required
        'UPLOAD_KEEP_FILENAME': True,
        'UPLOAD_KEEP_EXTENSIONS': True,
        'MAX_MEMORY_FILE_SIZE': 0
    }
    if request.headers['Content-Type'].startswith('multipart/form-data')==False:
        info = request.json
    else request.headers['Content-Type'].startswith('multipart/form-data'):
        parser = multipart.create_form_parser(
            headers=request.headers,
            on_field=on_field,
            on_file=on_file,
            config=con
        )

        while True:
            portion = request.stream.read(8192)
            if not portion:
                break
            parser.write(portion)
        parser.finalize()
        parser.close()

        if doc_obj is not None and not doc_obj.closed:
            doc_obj.close()


    if info.get('source_type') == 'url':
        url = info['source']
        info['file'] = info['name']

        setting= Config()
        is_fog = setting.get('cloud', False)
        if is_fog is True and ctx.user_class != 1:
            information = requests.head(url)
            doc_length = information.headers.get('Content-Length')
            try:
                doc_length = int(doc_length)
            except Exception:
                pass

            if doc_length is None:
                return http_error(
                    400,
                    "Error getting file info",
                    "Ð¡an't determine remote file size"
                )
            if doc_length > 1024 * 1024 * 100:
                return http_error(
                    400,
                    "File is too big",
                    "Upload limit for file is 100Mb"
                )
        with requests.get(url, stream=True) as r:
            if r.status_code != 200:
                return http_error(
                    400,
                    "Error getting file",
                    f"Got status code: {r.status_code}"
                )
            doc_dir = path.join(temp_dir_path, info['file'])
            with open(doc_dir, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)


    if  minds_doc_title in existing_file_names:
        return http_error(
            400,
            "File already exists",
            f"File with name '{info['file']}' already exists"
        )

    original_file_name = info.get('original_file_name')
    lp = doc_dir.lower()

    doc_dir = path.join(temp_dir_path, info['file'])
    if lp.endswith(('.zip', '.tar.gz')):
        if lp.endswith('.zip'):
            with zipfile.ZipFile(doc_dir) as f:
                f.extractall(temp_dir_path)
        elif lp.endswith('.tar.gz'):
            with tarfile.open(doc_dir) as f:
                safe