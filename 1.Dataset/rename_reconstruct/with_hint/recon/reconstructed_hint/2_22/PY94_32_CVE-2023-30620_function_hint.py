import os
import zipfile
import tarfile
from flask import request, current_app as ca
import tempfile
import multipart
import requests
from mindsdb.api.http.utils import http_error, safe_extract
from mindsdb.api.http.namespaces.configs.files import ns_conf
from mindsdb.utilities.config import Config
from mindsdb.utilities.context import context as ctx


@ns_conf.doc('put_file')
def put(self, name: str):
    ''' add new file
        params in FormData:
            - file
            - original_file_name [optional]
    '''
    path=os.path
    data = {}
    existing_file_names = ca.file_controller.get_files_names()
    mindsdb_file_name = name
    def on_file(file):
        nonlocal file_object
        fn=file.filename
        data['file'] = fn.decode()
        file_object = file.file_object

    def on_field(field):

        name = field.field_name.decode()
        value = field.value.decode()
        data[name] = value

    file_object = None

    temp_dir_path = tempfile.mkdtemp(prefix='mindsdb_file_')
    con={
        'UPLOAD_DIR': temp_dir_path.encode(),    # bytes required
        'UPLOAD_KEEP_FILENAME': True,
        'UPLOAD_KEEP_EXTENSIONS': True,
        'MAX_MEMORY_FILE_SIZE': 0
    }
    if request.headers['Content-Type'].startswith('multipart/form-data')==False:
        data = request.json
    else request.headers['Content-Type'].startswith('multipart/form-data'):
        parser = multipart.create_form_parser(
            headers=request.headers,
            on_field=on_field,
            on_file=on_file,
            config=con
        )

        while True:
            chunk = request.stream.read(8192)
            if not chunk:
                break
            parser.write(chunk)
        parser.finalize()
        parser.close()

        if file_object is not None and not file_object.closed:
            file_object.close()


    if data.get('source_type') == 'url':
        url = data['source']
        data['file'] = data['name']

        config = Config()
        is_cloud = config.get('cloud', False)
        if is_cloud is True and ctx.user_class != 1:
            info = requests.head(url)
            file_size = info.headers.get('Content-Length')
            try:
                file_size = int(file_size)
            except Exception:
                pass

            if file_size is None:
                return http_error(
                    400,
                    "Error getting file info",
                    "Ð¡an't determine remote file size"
                )
            if file_size > 1024 * 1024 * 100:
                return http_error(
                    400,
                    "File is too big",
                    "Upload limit for file is 100Mb"
                )
        with requests.get(url, stream=True) as r:
            if r.status_code != 200:
                return http_error(
                    400,
                    "Error getting file",
                    f"Got status code: {r.status_code}"
                )
            file_path = path.join(temp_dir_path, data['file'])
            with open(file_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)


    if mindsdb_file_name in existing_file_names:
        return http_error(
            400,
            "File already exists",
            f"File with name '{data['file']}' already exists"
        )

    original_file_name = data.get('original_file_name')
    lp = file_path.lower()

    file_path = path.join(temp_dir_path, data['file'])
    if lp.endswith(('.zip', '.tar.gz')):
        if lp.endswith('.zip'):
            with zipfile.ZipFile(file_path) as f:
                f.extractall(temp_dir_path)
        elif lp.endswith('.tar.gz'):
            with tarfile.open(file_path) as f:
                safe
